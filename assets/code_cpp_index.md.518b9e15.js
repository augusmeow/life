import{_ as s,c as a,o as n,Q as l}from"./chunks/framework.1cc28bed.js";const F=JSON.parse('{"title":"特性","description":"","frontmatter":{},"headers":[],"relativePath":"code/cpp/index.md","filePath":"code/cpp/index.md","lastUpdated":1692117387000}'),p={name:"code/cpp/index.md"},o=l(`<h1 id="特性" tabindex="-1">特性 <a class="header-anchor" href="#特性" aria-label="Permalink to &quot;特性&quot;">​</a></h1><h2 id="c-23-有什么新特性" tabindex="-1">C++23 有什么新特性 <a class="header-anchor" href="#c-23-有什么新特性" aria-label="Permalink to &quot;C++23 有什么新特性&quot;">​</a></h2><p>todo</p><h2 id="c-20-有什么新特性" tabindex="-1">C++20 有什么新特性 <a class="header-anchor" href="#c-20-有什么新特性" aria-label="Permalink to &quot;C++20 有什么新特性&quot;">​</a></h2><p>todo</p><h2 id="c-17-有什么新特性" tabindex="-1">C++17 有什么新特性 <a class="header-anchor" href="#c-17-有什么新特性" aria-label="Permalink to &quot;C++17 有什么新特性&quot;">​</a></h2><p>todo</p><h2 id="c-14-有什么新特性" tabindex="-1">C++14 有什么新特性 <a class="header-anchor" href="#c-14-有什么新特性" aria-label="Permalink to &quot;C++14 有什么新特性&quot;">​</a></h2><p>todo</p><h2 id="c-11-有什么新特性" tabindex="-1">C++11 有什么新特性 <a class="header-anchor" href="#c-11-有什么新特性" aria-label="Permalink to &quot;C++11 有什么新特性&quot;">​</a></h2><p>与之前的版本相比，C++11增加了许多新的特性，包括：</p><ul><li>新的类型：C++11增加了多种新的类型，例如auto和decltype，它们可以让程序员更容易地定义变量。</li><li>字面常量：C++11提供了新的字面常量，例如nullptr和u8&quot;hello&quot;，它们可以让程序员更方便地声明和使用指针和字符串。</li><li>智能指针：C++11提供了多种新的智能指针，例如unique_ptr和shared_ptr，它们可以自动管理内存，避免出现内存泄漏和野指针等错误。</li><li><a href="./concept/lambda#lambda-函数的特点和普通函数相比有什么优点">Lambda表达式</a>：C++11增加了Lambda表达式，它可以让程序员在代码中定义和使用匿名函数。</li><li>新的容器：C++11增加了多种新的容器，例如unordered_map和array，它们可以提高容器的性能和使用方便性。</li><li>多线程支持：C++11增加了对多线程的支持，它提供了一系列的多线程库，可以让程序员方便地编写多线程程序。</li></ul><p>除了以上特性之外，C++11还增加了许多其他的特性，例如对默认构造函数、拷贝构造函数、赋值运算符和移动运算符的编译器自动生成（叫做&quot;自动类型推导&quot;），以及对Unicode字符集的支持等等。</p><h3 id="线程库" tabindex="-1">线程库 <a class="header-anchor" href="#线程库" aria-label="Permalink to &quot;线程库&quot;">​</a></h3><p>C++11中提供了一个多线程库，它可以让程序员在C++代码中创建和管理多线程。这个库包含了许多类和函数，可以用来操作线程、互斥量、条件变量和其他的同步对象。</p><p>下面是一个简单的C++11多线程程序的例子，它创建了两个线程，分别打印&quot;hello&quot;和&quot;world&quot;：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">#include</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&lt;iostream&gt;</span></span>
<span class="line"><span style="color:#F97583;">#include</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&lt;thread&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::thread </span><span style="color:#B392F0;">t1</span><span style="color:#E1E4E8;">([]() { </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::cout </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;hello&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::endl; });</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::thread </span><span style="color:#B392F0;">t2</span><span style="color:#E1E4E8;">([]() { </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::cout </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;world&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::endl; });</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  t1.</span><span style="color:#B392F0;">join</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">  t2.</span><span style="color:#B392F0;">join</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">#include</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&lt;iostream&gt;</span></span>
<span class="line"><span style="color:#D73A49;">#include</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&lt;thread&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::thread </span><span style="color:#6F42C1;">t1</span><span style="color:#24292E;">([]() { </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::cout </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;hello&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::endl; });</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::thread </span><span style="color:#6F42C1;">t2</span><span style="color:#24292E;">([]() { </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::cout </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;world&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::endl; });</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  t1.</span><span style="color:#6F42C1;">join</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">  t2.</span><span style="color:#6F42C1;">join</span><span style="color:#24292E;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在这个程序中，我们使用了<code>std::thread</code>类来创建新的线程，并使用<code>join()</code>函数来等待线程结束。由于C++11的多线程库包含了许多类和函数，所以可以支持多种多线程编程模型，比如生产者-消费者模型、同步-异步模型等等。</p><p>在C++11中，如果想要使用多线程库，需要在代码中包含<code>&lt;thread&gt;</code>头文件。这个头文件包含了所有多线程库的声明，并且提供了一些宏定义和常量，可以用来查询系统的多线程支持情况。</p><p>例如，可以使用<code>std::thread::hardware_concurrency()</code>函数来获取系统的最大线程数，或者使用<code>std::this_thread::get_id()</code>函数来获取当前线程的标识符，等等。</p><p>除了<code>&lt;thread&gt;</code>头文件之外，C++11的多线程库还包含了其他几个头文件，它们可以用来实现更为复杂的多线程程序。例如，<code>&lt;mutex&gt;</code>头文件包含了互斥量类型和函数，可以用来保证多个线程对共享数据的互斥访问；<code>&lt;future&gt;</code>头文件包含了<code>future</code>和<code>promise</code>类型，可以用来实现线程间的同步和通信等等。</p><p>总之，C++11的多线程库为C++程序员提供了一系列的工具和类型，可以让他们编写高性能的多线程程序。</p><h3 id="智能指针" tabindex="-1">智能指针 <a class="header-anchor" href="#智能指针" aria-label="Permalink to &quot;智能指针&quot;">​</a></h3><p>智能指针是一种智能指针类型，它在管理内存时具有智能化的行为。普通的指针只能表示一个内存地址，而智能指针则具有自动释放内存和避免野指针等特性。</p><p>在C++11中，智能指针主要由两个模板类实现：<code>std::unique_ptr</code>和<code>std::shared_ptr</code>。</p><p><code>std::unique_ptr</code>表示一个独占的指针，它管理的内存在任何时候都只能被一个指针所指向。例如，当一个<code>std::unique_ptr</code>对象被析构时，它所管理的内存会被自动释放。 <code>std::shared_ptr</code>表示一个共享的指针，它管理的内存可以被多个指针所指向。例如，当一个<code>std::shared_ptr</code>对象的引用计数变为0时，它所管理的内存会被自动释放。 下面是一个使用<code>std::unique_ptr</code>的简单示例：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">#include</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&lt;iostream&gt;</span></span>
<span class="line"><span style="color:#F97583;">#include</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&lt;memory&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::unique_ptr</span><span style="color:#F97583;">&lt;int&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">p</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;">));</span><span style="color:#6A737D;">  // 声明一个独占指针，并分配一个int类型的对象</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::cout </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">p </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::endl;</span><span style="color:#6A737D;">  // 输出指针指向的对象的值</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">#include</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&lt;iostream&gt;</span></span>
<span class="line"><span style="color:#D73A49;">#include</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&lt;memory&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::unique_ptr</span><span style="color:#D73A49;">&lt;int&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">p</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">5</span><span style="color:#24292E;">));</span><span style="color:#6A737D;">  // 声明一个独占指针，并分配一个int类型的对象</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::cout </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">p </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::endl;</span><span style="color:#6A737D;">  // 输出指针指向的对象的值</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在这个程序中，我们声明了一个<code>std::unique_ptr</code>类型的指针p，并使用它来指向一个int类型的内存。我们可以通过解引用指针的方式来访问指针指向的对象，就像使用普通指针一样。当程序执行完毕，智能指针p会被析构，它所管理的内存就会被自动释放，避免了内存泄漏。</p><p>另一个模板类<code>std::shared_ptr</code>的用法也非常相似，下面是一个使用<code>std::shared_ptr</code>的简单示例：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">#include</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&lt;iostream&gt;</span></span>
<span class="line"><span style="color:#F97583;">#include</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&lt;memory&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::shared_ptr</span><span style="color:#F97583;">&lt;int&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">p1</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;">));</span><span style="color:#6A737D;">  // 声明一个共享指针，并分配一个int类型的对象</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::cout </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">p1 </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::endl;</span><span style="color:#6A737D;">  // 输出指针指向的对象的值</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::shared_ptr</span><span style="color:#F97583;">&lt;int&gt;</span><span style="color:#E1E4E8;"> p2 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> p1;</span><span style="color:#6A737D;">  // 将一个共享指针赋值给另一个共享指针</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::cout </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> p1.</span><span style="color:#B392F0;">use_count</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot; &quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> p2.</span><span style="color:#B392F0;">use_count</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::endl;</span><span style="color:#6A737D;">  // 输出两个指针的引用计数</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">#include</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&lt;iostream&gt;</span></span>
<span class="line"><span style="color:#D73A49;">#include</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&lt;memory&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::shared_ptr</span><span style="color:#D73A49;">&lt;int&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">p1</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">5</span><span style="color:#24292E;">));</span><span style="color:#6A737D;">  // 声明一个共享指针，并分配一个int类型的对象</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::cout </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">p1 </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::endl;</span><span style="color:#6A737D;">  // 输出指针指向的对象的值</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::shared_ptr</span><span style="color:#D73A49;">&lt;int&gt;</span><span style="color:#24292E;"> p2 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> p1;</span><span style="color:#6A737D;">  // 将一个共享指针赋值给另一个共享指针</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::cout </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> p1.</span><span style="color:#6F42C1;">use_count</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot; &quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> p2.</span><span style="color:#6F42C1;">use_count</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::endl;</span><span style="color:#6A737D;">  // 输出两个指针的引用计数</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在这个程序中，我们声明了两个<code>std::shared_ptr</code>类型的指针p1和p2，并让它们指向同一个int类型的对象。我们可以通过调用指针的<code>use_count()</code>方法来获取它的引用计数，表示当前有多少个指针指向这个内存。当程序执行完毕，如果所有的指针都被析构了，智能指针所管理的内存就会被自动释放，避免了内存泄漏。</p><p>总之，智能指针是C++11中一个非常实用的类型，它可以自动管理内存的生命周期，减少程序员手动管理内存的工作量，并且可以避免常见的内存错误。</p><h3 id="auto" tabindex="-1">auto <a class="header-anchor" href="#auto" aria-label="Permalink to &quot;auto&quot;">​</a></h3><blockquote><p>自动类型推导</p></blockquote><p>当与<code>const</code>结合使用时</p><ul><li>当类型不为引用时，auto 的推导结果将不保留表达式的 const 属性；</li><li>当类型为引用时，auto 的推导结果将保留表达式的 const 属性。</li></ul><p>auto的限制</p><ul><li><p>使用 auto 的时候必须对变量进行初始化</p></li><li><p>auto 不能在函数的参数中使用</p><ul><li>这个很容易理解，我们在定义函数的时候只是对参数进行了声明，指明了参数的类型，但并没有给它赋值，只有在实际调用函数的时候才会给参数赋值；而 auto 要求必须对变量进行初始化，所以这是矛盾的。</li></ul></li><li><p>auto 不能作用于类的非静态成员变量（也就是没有 static 关键字修饰的成员变量）中</p><ul><li>可以用<code>decltype</code>定义，如下就可以写成<code>decltype(T().begin()) m_it;</code></li></ul><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">template</span><span style="color:#E1E4E8;"> &lt;</span><span style="color:#F97583;">typename</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">A</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">private:</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">typename</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">::</span><span style="color:#B392F0;">iterator</span><span style="color:#E1E4E8;"> m_it;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">template</span><span style="color:#24292E;"> &lt;</span><span style="color:#D73A49;">typename</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">T</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">A</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#D73A49;">private:</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">typename</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">T</span><span style="color:#24292E;">::</span><span style="color:#6F42C1;">iterator</span><span style="color:#24292E;"> m_it;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div></li><li><p>auto 关键字不能定义数组</p></li><li><p>auto 不能作用于模板参数</p></li></ul><p>auto常用</p><ul><li>使用 auto 定义迭代器</li><li>auto 用于泛型编程</li></ul><h3 id="using" tabindex="-1">using <a class="header-anchor" href="#using" aria-label="Permalink to &quot;using&quot;">​</a></h3><p>使用<code>using</code>定义别名（替代<code>typedef</code>）</p><h3 id="支持函数模板的默认模板参数" tabindex="-1">支持函数模板的默认模板参数 <a class="header-anchor" href="#支持函数模板的默认模板参数" aria-label="Permalink to &quot;支持函数模板的默认模板参数&quot;">​</a></h3><p>函数模板是C++中一种常见的技术，它允许定义一个函数，接受任意类型的参数。例如，下面是一个简单的函数模板示例：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">#include</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&lt;iostream&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">template</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">typename</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">print</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">value</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::cout </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> value </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::endl;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">print</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">print</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;hello world&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">#include</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&lt;iostream&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">template</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">typename</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">T</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">print</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">T</span><span style="color:#24292E;"> </span><span style="color:#E36209;">value</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::cout </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> value </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::endl;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">print</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">5</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">print</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;hello world&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在这个程序中，我们定义了一个名为print的函数模板，它接受一个模板参数T，表示函数接受任意类型的参数。在函数体内，我们可以像使用普通类型一样使用这个模板参数T。</p><p>C++11标准引入了一种新的语法，允许为函数模板定义默认模板参数。例如，下面是一个使用默认模板参数的函数模板示例：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">#include</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&lt;iostream&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">template</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">typename</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> int&gt;</span></span>
<span class="line"><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">print</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">value</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::cout </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> value </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::endl;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">print</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">print</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;hello world&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">#include</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&lt;iostream&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">template</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">typename</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">T</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> int&gt;</span></span>
<span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">print</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">T</span><span style="color:#24292E;"> </span><span style="color:#E36209;">value</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::cout </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> value </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::endl;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">print</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">5</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">print</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;hello world&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在这个程序中，我们为函数模板print定义了一个默认模板参数T = int，表示如果调用函数时没有指定模板参数，就会使用默认的int类型作为模板参数。因此，在上面的程序中，调用函数print时，第一次调用会自动使用默认的模板参数int，并将实际参数5赋值给函数的形式参数value。</p><p>默认模板参数的作用是简化函数模板的调用，减少程序员的工作量。例如，我们可以通过使用默认模板参数，定义一个通用的排序函数，支持任意类型的数组排序，并且不需要显式地指定模板参数：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">#include</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&lt;algorithm&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">template</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">typename</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">sort</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">T</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">array</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">size</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::</span><span style="color:#B392F0;">sort</span><span style="color:#E1E4E8;">(array, array </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> size);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> array[] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">};</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">sort</span><span style="color:#E1E4E8;">(array, </span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">#include</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&lt;algorithm&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">template</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">typename</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">T</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">sort</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">T</span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#E36209;">array</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">size</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::</span><span style="color:#6F42C1;">sort</span><span style="color:#24292E;">(array, array </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> size);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> array[] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span><span style="color:#005CC5;">5</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">4</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">};</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">sort</span><span style="color:#24292E;">(array, </span><span style="color:#005CC5;">5</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在这个程序中，我们定义了一个名为sort的函数模板，它接受一个类型为T的数组和数组的长度作为参数。在函数体内，我们使用了C++标准库中的std::sort函数，将数组进行排序。因为我们没有为函数模板指定模板参数，所以编译器会自动推断出模板参数的类型，并使用默认的模板参数int进行编译。</p><p>总之，支持函数模板的默认模板参数是C++11标准的一项重要特性，它可以简化函数模板的定义和调用，提高程序的可读性和可维护性。</p><h2 id="by-stroustrup" tabindex="-1">by stroustrup <a class="header-anchor" href="#by-stroustrup" aria-label="Permalink to &quot;by stroustrup&quot;">​</a></h2><details class="details custom-block"><summary>C++11 features</summary><blockquote><p>C++11 feels like a new language -- stroustrup</p></blockquote><blockquote><p><a href="https://www.stroustrup.com/hopl20main-p5-p-bfc9cd4--final.pdf" target="_blank" rel="noreferrer">page29</a></p></blockquote><p>C++11 introduced a bewildering number of language features, including:</p><ul><li>memory model - an efficient low level-model of modern hardware as a foundation for concurrency</li><li>auto and decltype - avoiding redundant repetition of type names</li><li>range-for - simple linear traversal of ranges</li><li>move semantics and rvalue references - minimizing copying of data</li><li>uniform initialization - an (almost) completely general syntax and semantics for initializing objects of all kinds and types</li><li>nullptr - a name for the null pointer</li><li>constexpr functions - compile-time evaluated functions</li><li>user-defined literals - literals for user-defined types</li><li>raw string literals - literals where escape characters are not needed, mostly for regular expressions</li><li>attributes - associating essentially arbitrary information with a name</li><li>lambdas - unnamed function objects</li><li>variadic templates - templates that can handle an arbitrary number of arguments of arbitrary types</li><li>template aliases - the ability to rename a template and to bind some template arguments for the new name</li><li>noexcept - a way of ensuring that an exception isn’t thrown from a function</li><li>override and final - explicit syntax for managing large class hierarchies</li><li>static_assert - compile-time assertions</li><li>long long - a longer integer type</li><li>default member initializers - give a data member a default value that can be superseded by initialization in a constructor</li><li>enum classes - strongly typed enumerations with scoped enumerators</li></ul><p>And here is a list of the major standard-library components:</p><ul><li>unique_ptr and shared_ptr - resource-management pointers relying on RAII</li><li>memory model and atomic variables</li><li>thread, mutex, condition_variable, etc. - type-safe and portable support for basic system- level concurrency</li><li>future, promise, and packaged_task, etc. - slightly higher-level concurrency</li><li>tuple - unnamed simple composite types</li><li>type traits - testable properties of types for use in metaprogramming</li><li>regular expression matching</li><li>random numbers - with many generators (engines) and distributions</li><li>Time - time_point and duration</li><li>unordered_map, etc. - hash tables</li><li>forward_list - a singly-linked list</li><li>array - a fixed-constant-sized array that knows its size</li><li>emplace operations - construct objects right within a container to avoid copying</li><li>exception_ptr - enables transfer of exceptions between threads</li></ul></details><details class="details custom-block"><summary>C++17 features</summary><p>C++17 had about 21 new language features (depending on how you count), including:</p><ul><li>Constructor template argument deduction - simplify object definitions</li><li>Deduction guides - an explicit notation for resolving constructor template argument deduction ambiguities</li><li>Structured bindings - simplify notation and eliminate a source of uninitialized variables</li><li>inline variables - simplify the use of statically allocated variables in header-only libraries</li><li>Fold expressions - simplify some uses of variadic templates</li><li>Explicit test in conditions - a bit like conditions in for-statements</li><li>Guaranteed copy elision - eliminate many redundant copy operations</li><li>Stricter expression evaluation order - prevents some subtle order-of-evaluation mistakes</li><li>auto as a template argument type - type deduction for value template arguments</li><li>Standard attributes to catch common mistakes - <code>[[maybe_unused]]</code>, <code>[[nodiscard]]</code>, and <code>[[fallthrough]]</code></li><li>Hexadecimal floating-point literals</li><li>Constant expression if - simplify compile-time evaluated code</li></ul><p>The C++17 standard-library added about 13 new features plus many minor modifications:</p><ul><li>optional, variant, and any - standard-library types for expressing alternatives</li><li>shared_mutex and shared_lock (reader-writer locks) and scoped_lock</li><li>parallel STL - multi-threaded and/or vectorized versions of standard-library algorithms</li><li>file system - the ability to portably manipulate file-system paths and directories</li><li>string_view - a non-owning reference to an immutable sequence of characters</li><li>Mathematical special functions - including Laguerre and Legendre polynomials, beta func- tions, Riemann zeta function</li></ul></details>`,56),e=[o];function t(c,r,i,y,E,d){return n(),a("div",null,e)}const m=s(p,[["render",t]]);export{F as __pageData,m as default};

import{_ as e,c as t,a3 as o,o as l}from"./chunks/framework.DDs3IadZ.js";const m=JSON.parse('{"title":"Lambda","description":"","frontmatter":{},"headers":[],"relativePath":"code/cpp/concept/lambda.md","filePath":"code/cpp/concept/lambda.md","lastUpdated":1716791141000}'),r={name:"code/cpp/concept/lambda.md"};function i(d,a,c,n,p,s){return l(),t("div",null,a[0]||(a[0]=[o('<h1 id="lambda" tabindex="-1">Lambda <a class="header-anchor" href="#lambda" aria-label="Permalink to &quot;Lambda&quot;">​</a></h1><h2 id="stroustrup-intro" tabindex="-1">stroustrup intro <a class="header-anchor" href="#stroustrup-intro" aria-label="Permalink to &quot;stroustrup intro&quot;">​</a></h2><p>from <a href="https://www.stroustrup.com/hopl20main-p5-p-bfc9cd4--final.pdf" target="_blank" rel="noreferrer">Thriving in a Crowded and Changing World: C++ 2006-2020</a>(p53)</p><blockquote><p>The lambda library was a masterpiece of early template metaprogramming and very convenient and popular. Unfortunately, it wasn&#39;t particularly efficient. For years, I tracked its performance relative to hand-coded equivalents and found a fairly consistent 2.5 times overhead. I could not recommend something that was convenient, but slow. Doing so would damage C++’s reputation as a language for efficient code</p></blockquote><p>lambda 表达式库是早期模板元编程的典范，非常方便和流行。不幸的是，它的效率并不特别高。多年来，我追踪了它相对于手工编码的同等实现的性能，发现它的开销是后者的 2.5 倍且这种差距相当一致。我不能推荐一种方便但却很慢的东西。这样做会损害C++ 作为产生高效代码的语言的声誉。</p><p>from <a href="https://www.stroustrup.com/hopl20main-p5-p-bfc9cd4--final.pdf" target="_blank" rel="noreferrer">Thriving in a Crowded and Changing World: C++ 2006-2020</a>(p55)</p><blockquote><p>If the callback is invoked on the same thread as test, <code>[&amp;s]</code> capture is potentially efficient because s is not copied. If the callback is invoked on a different thread, <code>[&amp;s]</code> capture could be a disaster because s could go out of scope before it was used; in that case, we want a copy. A <code>[=]</code> capture list means &quot;copy all local variables into the lambda.&quot; A <code>[&amp;]</code> capture list means &quot;the lambda can refer to all local variables by reference&quot; and implies that the lambda can be implemented as simply a local function.</p></blockquote><p>如果回调函数在与 test 相同的线程上被调用，<code>[&amp;s]</code> 捕获可能效率更高，因为 s 没有被复制。如果回调函数在不同的线程上被调用，<code>[&amp;s]</code> 捕获可能是一个灾难，因为 s在被使用之前可能会超出作用域；这种情况下，我们想要一份副本。一个 <code>[=]</code> 捕获列表意味着“将所有局部变量复制到 lambda 表达式中”。而一个 <code>[&amp;]</code> 捕获列表意味着“lambda 表达式可以通过引用指代所有局部变量”，并意味着lambda 表达式可以简单地实现为一个局部函数。</p><h2 id="other" tabindex="-1">other <a class="header-anchor" href="#other" aria-label="Permalink to &quot;other&quot;">​</a></h2><p>lambda 表达式的价值在于，就地封装短小的功能闭包，可以极其方便地表达出我们希望执行的具体操作，并让上下文结合得更加紧密。 lambda 表达式的类型在 C++11 中被称为“闭包类型（Closure Type）”。它是一个特殊的，匿名的非 union 的类类型。 lambda表达式有如下优点：</p><ul><li>声明式编程风格：就地匿名定义目标函数或函数对象，不需要额外写一个命名函数或者函数对象。以更直接的方式去写程序，好的可读性和可维护性。</li><li>简洁：不需要额外再写一个函数或者函数对象，避免了代码膨胀和功能分散，让开发者更加集中精力在手边的问题，同时也获取了更高的生产率。 在需要的时间和地点实现功能闭包，使程序更灵活。</li></ul><p>语法形式 <code>[ capture ] ( params ) opt -&gt; ret { body; };</code> 其中 capture 是捕获列表，params 是参数表，opt 是函数选项，ret 是返回值类型，body是函数体。 lambda 表达式还可以通过捕获列表捕获一定范围内的变量：</p><ul><li><code>[]</code> 不捕获任何变量。</li><li><code>[&amp;]</code> 捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。</li><li><code>[=]</code> 捕获外部作用域中所有变量，并作为副本在函数体中使用（按值捕获）。</li><li><code>[=, &amp;foo]</code> 按值捕获外部作用域中所有变量，并按引用捕获 foo 变量。</li><li><code>[bar]</code> 按值捕获 bar 变量，同时不捕获其他变量。</li><li><code>[this]</code> 捕获当前类中的 this 指针，让 lambda</li></ul><p>表达式拥有和当前类成员函数同样的访问权限。如果已经使用了 &amp; 或者 =，就默认添加此选项。捕获 this 的目的是可以在 lambda 中使用当前类的成员函数和成员变量。</p><p>Lambda表达式完整的声明格式如下： <code>[capture list] (params list) mutable exception-&gt; return type { function body }</code> 各项具体含义如下</p><ul><li>capture list：捕获外部变量列表</li><li>params list：形参列表</li><li>mutable指示符：用来说用是否可以修改捕获的变量</li><li>exception：异常设定</li><li>return type：返回类型</li><li>function body：函数体</li></ul><p>此外，我们还可以省略其中的某些成分来声明“不完整”的Lambda表达式，常见的有以下几种：</p><ol><li><code>[capture list] (params list) -&gt; return type {function body}</code></li><li><code>[capture list] (params list) {function body}</code></li><li><code>[capture list] {function body}</code></li></ol><p>其中： 格式1声明了const类型的表达式，这种类型的表达式不能修改捕获列表中的值。 格式2省略了返回值类型，但编译器可以根据以下规则推断出Lambda表达式的返回类型： （1）：如果function body中存在return语句，则该Lambda表达式的返回类型由return语句的返回类型确定； （2）：如果function body中没有return语句，则返回值为void类型。 格式3中省略了参数列表，类似普通函数中的无参函数。</p>',19)]))}const b=e(r,[["render",i]]);export{m as __pageData,b as default};

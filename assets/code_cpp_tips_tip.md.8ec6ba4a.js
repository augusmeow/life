import{_ as s,c as n,o as a,Q as l}from"./chunks/framework.1cc28bed.js";const u=JSON.parse('{"title":"一些要点","description":"","frontmatter":{},"headers":[],"relativePath":"code/cpp/tips/tip.md","filePath":"code/cpp/tips/tip.md","lastUpdated":1682241312000}'),p={name:"code/cpp/tips/tip.md"},o=l(`<h1 id="一些要点" tabindex="-1">一些要点 <a class="header-anchor" href="#一些要点" aria-label="Permalink to &quot;一些要点&quot;">​</a></h1><h2 id="二维动态数组的申请和删除" tabindex="-1">二维动态数组的申请和删除 <a class="header-anchor" href="#二维动态数组的申请和删除" aria-label="Permalink to &quot;二维动态数组的申请和删除&quot;">​</a></h2><p>首先是如何申请二维的数组，这里我们先申请一个指针数组，然后令指针数组中的每一个元素都指向一个数组，这样二维数组就成了：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">size_t</span><span style="color:#E1E4E8;"> row, col;</span></span>
<span class="line"><span style="color:#6A737D;">//输入row和col的数值</span></span>
<span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">**</span><span style="color:#E1E4E8;">MathTable </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int*</span><span style="color:#E1E4E8;">[row];</span></span>
<span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> row; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">  MathTable[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[col];</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">size_t</span><span style="color:#24292E;"> row, col;</span></span>
<span class="line"><span style="color:#6A737D;">//输入row和col的数值</span></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">**</span><span style="color:#24292E;">MathTable </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int*</span><span style="color:#24292E;">[row];</span></span>
<span class="line"><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> row; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">  MathTable[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[col];</span></span></code></pre></div><p>然后是释放空间的过程：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">//code</span></span>
<span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> row; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">delete[]</span><span style="color:#E1E4E8;"> MathTable[i];</span></span>
<span class="line"><span style="color:#F97583;">delete</span><span style="color:#E1E4E8;">[]MathTable;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">//code</span></span>
<span class="line"><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> row; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">delete[]</span><span style="color:#24292E;"> MathTable[i];</span></span>
<span class="line"><span style="color:#D73A49;">delete</span><span style="color:#24292E;">[]MathTable;</span></span></code></pre></div><p>符合new和delete配对的原则，怎么new出来就怎么delete掉。</p><h2 id="为什么要内存对齐" tabindex="-1"><a href="https://blog.csdn.net/lgouc/article/details/82354710" target="_blank" rel="noreferrer">为什么要内存对齐</a> <a class="header-anchor" href="#为什么要内存对齐" aria-label="Permalink to &quot;[为什么要内存对齐](https://blog.csdn.net/lgouc/article/details/82354710)&quot;">​</a></h2><h2 id="将程序跳转到指定内存地址" tabindex="-1">将程序跳转到指定内存地址 <a class="header-anchor" href="#将程序跳转到指定内存地址" aria-label="Permalink to &quot;将程序跳转到指定内存地址&quot;">​</a></h2><p>要对绝对地址0x100000赋值，我们可以用<code>(unsigned int*)0x100000 = 1234;</code>那么要是想让程序跳转到绝对地址是0x100000去执行，应该怎么做？</p><p><code>*((void (*)( ))0x100000 ) ( );</code> 首先要将0x100000强制转换成函数指针,即: <code>(void (*)())0x100000</code> 然后再调用它: <code>*((void (*)())0x100000)();</code> 用typedef可以看得更直观些: <code>typedef void(*)() voidFuncPtr;</code><code>*((voidFuncPtr)0x100000)();</code></p><h2 id="如何实现仿函数-为什么需要通过继承自unary-function-或者-binary-function来实现仿函数" tabindex="-1">如何实现仿函数？为什么需要通过继承自unary_function 或者 binary_function来实现仿函数？ <a class="header-anchor" href="#如何实现仿函数-为什么需要通过继承自unary-function-或者-binary-function来实现仿函数" aria-label="Permalink to &quot;如何实现仿函数？为什么需要通过继承自unary_function 或者 binary_function来实现仿函数？&quot;">​</a></h2><p>function object就是重载了函数调用操作符 operator()的一个struct或者class 所有内置一元仿函数均继承自unary_function，所有内置二元仿函数均继承自binary_function 继承自unary_function和binary_function的仿函数可以成为“可配接“的仿函数。可配接的仿函数，能够与其他STL组件更”和谐“地协同工作。</p><h2 id="什么是字节对齐-为什么要采用这种机制" tabindex="-1">什么是字节对齐，为什么要采用这种机制？ <a class="header-anchor" href="#什么是字节对齐-为什么要采用这种机制" aria-label="Permalink to &quot;什么是字节对齐，为什么要采用这种机制？&quot;">​</a></h2><p>字节对齐是指将数据按字节的边界对齐到指定的地址，使得数据在内存中的存储位置更加合理。通常来说，对齐的字节数是 2 的整数次幂，比如 1、2、4 或 8 字节。</p><p>采用字节对齐机制的原因有以下几个：</p><ul><li>提高内存访问效率。如果数据不对齐，那么当 CPU 读取数据时，它可能需要进行多次内存访问，从而降低内存访问效率。而如果数据对齐，那么 CPU 就可以在一次内存访问中读取整个数据，从而提高内存访问效率。</li><li>减少内存空间的浪费。如果数据不对，那么可能会出现内存碎片，即某些内存空间无法被使用。而如果数据对齐，那么可以避免内存碎片的产生，从而减少内存的浪费。</li><li>提高软件的可移植性。由于不同的 CPU 架构有不同的字长和对齐规则，如果软件不进行字节对齐，那么在不同的 CPU 架构下可能会出现问题。而如果进行字节对齐，那么软件就可以在不同的 CPU 架构下运行，从而提高软件的可移植性。</li></ul><p>总之，字节对齐是一种有用的机制，它能够提高内存访问效率、减少内存空间的浪费以及提高软件的可移植性。不同的编程语言和编译器都会提供字节对齐的机制，开发人员可以根据需要来选择是否使用这种机制。</p><h2 id="两种常用的实现隐式类类型转换的方式是什么-如何避免隐式类型转换" tabindex="-1">两种常用的实现隐式类类型转换的方式是什么？如何避免隐式类型转换？ <a class="header-anchor" href="#两种常用的实现隐式类类型转换的方式是什么-如何避免隐式类型转换" aria-label="Permalink to &quot;两种常用的实现隐式类类型转换的方式是什么？如何避免隐式类型转换？&quot;">​</a></h2><ol><li><p>使用单参数的构造函数或N个参数中有N-1个是默认参数的构造函数，</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">A</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">public:</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">A</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">string</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">s</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">A</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">string</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">s</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">a</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">A</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#D73A49;">public:</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">A</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">string</span><span style="color:#24292E;"> </span><span style="color:#E36209;">s</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">A</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">string</span><span style="color:#24292E;"> </span><span style="color:#E36209;">s</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">a</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">};</span></span></code></pre></div><p>使用operator what_you_want_to_convert_type() const</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">A</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">public:</span></span>
<span class="line"><span style="color:#E1E4E8;">     </span><span style="color:#F97583;">operator</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">char</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">*</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">         </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> data;</span><span style="color:#6A737D;">//当从其他类型转换到char*时自动调用</span></span>
<span class="line"><span style="color:#E1E4E8;">     }</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">private:</span></span>
<span class="line"><span style="color:#E1E4E8;">     </span><span style="color:#F97583;">char</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">data;</span></span>
<span class="line"><span style="color:#E1E4E8;"> };</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">A</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#D73A49;">public:</span></span>
<span class="line"><span style="color:#24292E;">     </span><span style="color:#D73A49;">operator</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">char</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">*</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">         </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> data;</span><span style="color:#6A737D;">//当从其他类型转换到char*时自动调用</span></span>
<span class="line"><span style="color:#24292E;">     }</span></span>
<span class="line"><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#D73A49;">private:</span></span>
<span class="line"><span style="color:#24292E;">     </span><span style="color:#D73A49;">char</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">data;</span></span>
<span class="line"><span style="color:#24292E;"> };</span></span></code></pre></div></li><li><p>在单参数的构造函数或N个参数中有N-1个是默认参数的构造函数声明之前加上explicit。</p></li></ol><h2 id="面向对象的设计原则" tabindex="-1">面向对象的设计原则 <a class="header-anchor" href="#面向对象的设计原则" aria-label="Permalink to &quot;面向对象的设计原则&quot;">​</a></h2><p>面向对象设计是指使用继承和抽象来创建可重用的类和对象的方法。面向对象设计原则的目的是提高软件系统的质量和灵活性。常见的面向对象设计原则包括单一职责原则、开放封闭原则、里氏替换原则、接口隔离原则、依赖反转原则等。</p><h2 id="函数调用的具体实现" tabindex="-1">函数调用的具体实现 <a class="header-anchor" href="#函数调用的具体实现" aria-label="Permalink to &quot;函数调用的具体实现&quot;">​</a></h2><p>函数调用的具体实现取决于编程语言和使用的计算机体系结构。但是，一般来说，在进行函数调用时，首先会在函数的调用点保存当前的执行上下文，然后将控制权转移到函数的定义体开头执行。在函数执行完毕后，会恢复之前保存的执行上下文，并将控制权返回到调用点。</p><p>为了实现函数调用，计算机系统通常会使用一个栈来保存执行上下文。每当进行函数调用时，就会将当前的执行上下文压入栈中，并在函数执行完毕后弹出栈顶元素。这样，在函数调用过程中，栈中保存的就是当前函数调用的堆栈跟踪信息。</p><h2 id="构造函数可以调用虚函数吗-语法上通过吗-语义上可以通过吗" tabindex="-1">构造函数可以调用虚函数吗？语法上通过吗？语义上可以通过吗？ <a class="header-anchor" href="#构造函数可以调用虚函数吗-语法上通过吗-语义上可以通过吗" aria-label="Permalink to &quot;构造函数可以调用虚函数吗？语法上通过吗？语义上可以通过吗？&quot;">​</a></h2><p>不能，语法上通过，语义上有问题。<code>derived class</code>对象内的<code>base class</code>成分会在<code>derived class</code>自身构造之前构造完毕。因此，在<code>base class</code>的构造函数中执行的<code>virtual</code>函数将会是<code>base class</code>的版本，决不会是<code>derived class</code>的版本。 即使目前确实正在构造<code>derived class</code>。</p><h2 id="拷贝构造函数作用及用途-什么时候需要自定义拷贝构造函数" tabindex="-1">拷贝构造函数作用及用途？什么时候需要自定义拷贝构造函数？ <a class="header-anchor" href="#拷贝构造函数作用及用途-什么时候需要自定义拷贝构造函数" aria-label="Permalink to &quot;拷贝构造函数作用及用途？什么时候需要自定义拷贝构造函数？&quot;">​</a></h2><ul><li>在C++中，有下面三种对象需要拷贝的情况： <ul><li>一个对象以值传递的方式传入函数体</li><li>一个对象以值传递的方式从函数返回</li><li>一个对象需要通过另外一个对象进行初始化 以上的情况就需要拷贝构造函数的调用。</li></ul></li><li>当类中的数据成员需要动态分配存储空间时，不可以依赖<code>default copy constructor</code>。当<code>default copy constructor</code> 被因编译器需要而合成时，将执行<code>default memberwise copy</code>语义。 此时如果类中有动态分配的存储空间时，将会发生惨重的灾情。 在需要时（包括这种对象要赋值、这种对象作为函数参数要传递、函数返回值为这种对象等情况），要考虑到自定义拷贝构造函数。</li></ul><h2 id="如果在构造函数和析构函数中抛出异常会发生什么-什么是栈展开" tabindex="-1">如果在构造函数和析构函数中抛出异常会发生什么？什么是栈展开？ <a class="header-anchor" href="#如果在构造函数和析构函数中抛出异常会发生什么-什么是栈展开" aria-label="Permalink to &quot;如果在构造函数和析构函数中抛出异常会发生什么？什么是栈展开？&quot;">​</a></h2><ul><li>构造函数抛异常：不会发生资源泄漏。假设在operator new() 时抛出异常，那么将会因异常而结束此次调用，内存分配失败，不可能存在内存泄露。假设在别处(operator new() ) 执行之后抛出异常，此时析构函数调用，已构造的对象将得以正确释放，且自动调用operator delete()释放内存 析构函数抛异常： 可以抛出异常，但该异常必须留在析构函数；若析构函数因异常退出，情况会很糟糕(all kinds of bad things are likely to happen)</li><li>可能使得已分配的对象未能正常析构，造成内存泄露； <ul><li>例如在对像数组的析构时，如果对象的析构函数抛出异常，释放代码将引发未定义行为。考虑一个对象数组的中间部分在析构时抛出异常，它无法传播，因为传播的话将使得后续部分不能正常释放；它也无法吸收，因为这违反了”异常中立“原则( 异常中立，就是指任何底层的异常都会抛出到上层，也就相当于是异常透明的)。</li></ul></li><li>抛出异常时，将暂停当前函数的执行，开始查找匹配的catch子句。<br> 首先检查throw本身是否在try块内部如果是，检查与该try相关的catch子句，看是否可以处理该异常。如果不能处理，就退出当前函数，并且释放当前函数的内存并销毁局部对象，继续到上层的调用函数中查找，直到找到一个可以处理该异常的catch。</li></ul><h2 id="virtual函数能声明为内联吗-为什么" tabindex="-1">virtual函数能声明为内联吗？为什么？ <a class="header-anchor" href="#virtual函数能声明为内联吗-为什么" aria-label="Permalink to &quot;virtual函数能声明为内联吗？为什么？&quot;">​</a></h2><ul><li>通常情况下是不能的</li><li>原因：inline是编译期决定，他意味着在执行前就将调用动作替换为被调用函数的本体； virtual是运行期决定，他意味着直道运行期才决定调用哪个函数。 这两者之间通常是冲突的。 然而也有特例，就是当编译阶段就已经知道调用虚函数的指针为多态指针。这里就不再赘述了。</li></ul><h2 id="哪些类型的对象不可以作为union的成员-为什么有这种限制" tabindex="-1">哪些类型的对象不可以作为union的成员？为什么有这种限制？ <a class="header-anchor" href="#哪些类型的对象不可以作为union的成员-为什么有这种限制" aria-label="Permalink to &quot;哪些类型的对象不可以作为union的成员？为什么有这种限制？&quot;">​</a></h2><p>标准规定，凡是具有<code>non-trivial constructor</code>、<code>non-trivial destructor</code>、<code>non-trivial copy constructor</code> 、<code>non-trivial assignment operator</code>的class对象都不能作为union的成员。 即是说，这个class的以上四种成员必须均经由编译器合成且该class无虚函数和虚基类。 有这种限制是为了兼容C。</p><h2 id="c-中的转化机制-各适用于什么环境-dynamic-cast转换失败时-会出现什么情况" tabindex="-1">C++中的转化机制？各适用于什么环境？dynamic_cast转换失败时，会出现什么情况？ <a class="header-anchor" href="#c-中的转化机制-各适用于什么环境-dynamic-cast转换失败时-会出现什么情况" aria-label="Permalink to &quot;C++中的转化机制？各适用于什么环境？dynamic_cast转换失败时，会出现什么情况？&quot;">​</a></h2><p>对指针，返回NULL.对引用，抛出bad_cast异常more Effective C++ C++引入了4种类型转化操作符（cast operator）：static_cast，const_cast，dynamic_cast和reinterpret_cast，使用方法与C语言中略有不同：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">(type)expression;</span><span style="color:#6A737D;"> //这是C语言的</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">(type)expression;</span><span style="color:#6A737D;"> //这是C语言的</span></span></code></pre></div><p>然后引入C++的：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">static_cast&lt;</span><span style="color:#E1E4E8;">type</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;">(expression);</span><span style="color:#6A737D;">//这是C++的</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">static_cast&lt;</span><span style="color:#24292E;">type</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;">(expression);</span><span style="color:#6A737D;">//这是C++的</span></span></code></pre></div><p>然后看一下各自的适用范围：</p><ul><li><p>static_cast：static_cast基本上拥有与C旧式转型相同的威力和意义，以及相同的限制。但是，该类型转换操作符不能移除常量性，因为有一个专门的操作符用来移除常量性。</p></li><li><p>const_cast：用来改变表达式中的常量性（constness）或者易变形（volatileness），只能用于此功能。</p></li><li><p>dynamic_cast：将指向基类basic class object的pointer或者reference转型为指向派生类derived（或这sibling base）class object的pointer或者reference中，并且可以获知是否转型成功：如果转型失败，当转型对象是指针的时候会返回一个null指针；当转型对象是reference会抛出一个异常exception。dynamic_cast无法应用在缺乏虚函数的类型上，也不能改变类型的常量性。 此外，dynamic_cast还有一个用途就是找出被对象占用的内存的起始点。</p></li><li><p>reinterpret_cast：这个操作符的转换结果几乎总是和编译器平台相关，所以不具有移植性。reinterpret_cast的最常用用途是转换“函数指针”类型，如下：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">typedef</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> (*FuncPtr)();</span></span>
<span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">doSomething</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    FuncPtr funcPtrArray[</span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#E1E4E8;">    funcPtrArray[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">reinterpret_cast&lt;</span><span style="color:#E1E4E8;">FuncPtr</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">doSomething);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">typedef</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> (*FuncPtr)();</span></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">doSomething</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    FuncPtr funcPtrArray[</span><span style="color:#005CC5;">10</span><span style="color:#24292E;">];</span></span>
<span class="line"><span style="color:#24292E;">    funcPtrArray[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">reinterpret_cast&lt;</span><span style="color:#24292E;">FuncPtr</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;">doSomething);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>通过reinterpret_cast强迫编译器了，并成功的将不同的类型的函数&amp;doSomething转换为需要的类型。不过这个操作符进行的转换动作不具有移植性（C++不保证所有的函数指针都能以此方式重新呈现），某些情况下这样的转型可能会导致不正确的结果，所以这种操作不到万不得已不要使用。</p></li></ul><h2 id="有哪几种强制类型转换以及使用场景" tabindex="-1">有哪几种强制类型转换以及使用场景 <a class="header-anchor" href="#有哪几种强制类型转换以及使用场景" aria-label="Permalink to &quot;有哪几种强制类型转换以及使用场景&quot;">​</a></h2><ol><li>静态类型转换（static_cast）：该类型转换是最常用的强制类型转换方式，它支持转换基本数据类型、指针、引用和枚举类型。</li><li>动态类型转换（dynamic_cast）：该类型转换主要用于转换基类指针或引用到派生类指针或引用，并在运行时检查转换是否成功。</li><li>常量类型转换（const_cast）：该类型转换可以用来去除或添加对象的常量属性。</li><li>向上转型（reinterpret_cast）：该类型转换可以用来进行位域转换，或将任意类型的指针转换为任意其它类型的指针。</li></ol><p>使用场景方面，C++ 中的强制类型转换主要用于两类情况：</p><ol><li>转换不同类型的数据：在 C++ 中，数据的类型是严格检查的，因此如果需要进行类型不同的数据运算，就必须先进行强制类型转换。</li><li>转换基类指针或引用到派生类指针或引用：在 C++ 中，继承关系中的类之间可以相互转换，但是这种转换需要使用动态类型转换进行。例如，假设有一个基类 Base 和一个派生类 Derived，那么可以使用动态类型转换将基类指针转换为派生类指针，从而调用派生类中特有的成员函数。</li></ol><p>下面是一个简单的例子：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Base</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">public:</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">virtual</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">doSomething</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#6A737D;">    // 在基类中实现的通用操作</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Derived</span><span style="color:#E1E4E8;"> : </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Base</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">public:</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">doSomething</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#6A737D;">    // 在派生类中重写的 doSomething 操作</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">doSomethingElse</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#6A737D;">    // 派生类中独有的操作</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">  Base</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> b </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Base</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">  b-&gt;</span><span style="color:#B392F0;">doSomething</span><span style="color:#E1E4E8;">();</span><span style="color:#6A737D;">  // 调用基类中的 doSomething 操作</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  Derived</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> d </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">dynamic_cast&lt;</span><span style="color:#E1E4E8;">Derived</span><span style="color:#F97583;">*&gt;</span><span style="color:#E1E4E8;">(b);</span></span>
<span class="line"><span style="color:#E1E4E8;">  d-&gt;</span><span style="color:#B392F0;">doSomething</span><span style="color:#E1E4E8;">();</span><span style="color:#6A737D;">  // 调用派生类中重写的 doSomething 操作</span></span>
<span class="line"><span style="color:#E1E4E8;">  d-&gt;</span><span style="color:#B392F0;">doSomethingElse</span><span style="color:#E1E4E8;">();</span><span style="color:#6A737D;">  // 调用派生类中独有的 doSomethingElse 操作</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Base</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#D73A49;">public:</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">virtual</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">doSomething</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#6A737D;">    // 在基类中实现的通用操作</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Derived</span><span style="color:#24292E;"> : </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Base</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#D73A49;">public:</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">doSomething</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#6A737D;">    // 在派生类中重写的 doSomething 操作</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">doSomethingElse</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#6A737D;">    // 派生类中独有的操作</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  Base</span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> b </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Base</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">  b-&gt;</span><span style="color:#6F42C1;">doSomething</span><span style="color:#24292E;">();</span><span style="color:#6A737D;">  // 调用基类中的 doSomething 操作</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  Derived</span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> d </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">dynamic_cast&lt;</span><span style="color:#24292E;">Derived</span><span style="color:#D73A49;">*&gt;</span><span style="color:#24292E;">(b);</span></span>
<span class="line"><span style="color:#24292E;">  d-&gt;</span><span style="color:#6F42C1;">doSomething</span><span style="color:#24292E;">();</span><span style="color:#6A737D;">  // 调用派生类中重写的 doSomething 操作</span></span>
<span class="line"><span style="color:#24292E;">  d-&gt;</span><span style="color:#6F42C1;">doSomethingElse</span><span style="color:#24292E;">();</span><span style="color:#6A737D;">  // 调用派生类中独有的 doSomethingElse 操作</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在上面的例子中，我们首先定义了一个基类 Base 和一个派生类 Derived。然后在 main 函数中，我们先创建了一个基类指针 b，并通过该指针调用了基类中的 doSomething 操作。</p><p>接着，我们使用动态类型转换将 b 转换为派生类指针 d，并通过 d 调用了派生类中重写的 doSomething 操作和独有的 doSomethingElse</p><p>在上面的例子中，我们通过动态类型转换将基类指针转换为派生类指针，从而实现了基类指针向派生类指针的转换。但是，这种转换并不是没有风险的。如果指针 b 实际指向的对象并不是一个派生类的对象，那么动态类型转换将会失败，从而导致程序崩溃。</p><p>为了避免这种情况的发生，在进行动态类型转换时，可以使用特殊的语法来检查转换是否成功。例如，可以改写上面的例子如下：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Base</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">public:</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">virtual</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">doSomething</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#6A737D;">    // 在基类中实现的通用操作</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Derived</span><span style="color:#E1E4E8;"> : </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Base</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">public:</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">doSomething</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#6A737D;">    // 在派生类中重写的 doSomething 操作</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">doSomethingElse</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#6A737D;">    // 派生类中独有的操作</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">  Base</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> b </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Base</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">  b-&gt;</span><span style="color:#B392F0;">doSomething</span><span style="color:#E1E4E8;">();</span><span style="color:#6A737D;">  // 调用基类中的 doSomething 操作</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  Derived</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> d </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">dynamic_cast&lt;</span><span style="color:#E1E4E8;">Derived</span><span style="color:#F97583;">*&gt;</span><span style="color:#E1E4E8;">(b);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (d </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nullptr</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    d-&gt;</span><span style="color:#B392F0;">doSomething</span><span style="color:#E1E4E8;">();</span><span style="color:#6A737D;">  // 调用派生类中重写的 doSomething 操作</span></span>
<span class="line"><span style="color:#E1E4E8;">    d-&gt;</span><span style="color:#B392F0;">doSomethingElse</span><span style="color:#E1E4E8;">();</span><span style="color:#6A737D;">  // 调用派生类中独有的 doSomethingElse 操作</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#6A737D;">    // 如果转换失败，则不执行任何操作</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Base</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#D73A49;">public:</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">virtual</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">doSomething</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#6A737D;">    // 在基类中实现的通用操作</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Derived</span><span style="color:#24292E;"> : </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Base</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#D73A49;">public:</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">doSomething</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#6A737D;">    // 在派生类中重写的 doSomething 操作</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">doSomethingElse</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#6A737D;">    // 派生类中独有的操作</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  Base</span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> b </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Base</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">  b-&gt;</span><span style="color:#6F42C1;">doSomething</span><span style="color:#24292E;">();</span><span style="color:#6A737D;">  // 调用基类中的 doSomething 操作</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  Derived</span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> d </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">dynamic_cast&lt;</span><span style="color:#24292E;">Derived</span><span style="color:#D73A49;">*&gt;</span><span style="color:#24292E;">(b);</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (d </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nullptr</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    d-&gt;</span><span style="color:#6F42C1;">doSomething</span><span style="color:#24292E;">();</span><span style="color:#6A737D;">  // 调用派生类中重写的 doSomething 操作</span></span>
<span class="line"><span style="color:#24292E;">    d-&gt;</span><span style="color:#6F42C1;">doSomethingElse</span><span style="color:#24292E;">();</span><span style="color:#6A737D;">  // 调用派生类中独有的 doSomethingElse 操作</span></span>
<span class="line"><span style="color:#24292E;">  } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#6A737D;">    // 如果转换失败，则不执行任何操作</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在上面的例子中，我们通过检查 d 是否为 nullptr 来判断动态类型转换是否成功。如果转换成功，则 d 指向一个派生类对象，否则 d 指向 nullptr。</p><p>在进行动态类型转换时，检查转换是否成功是一个很好的实跃。它可以帮助我们避免对于非法对象进行操作，从而保证程序的正确性和安全性。</p><p>除了动态类型转换之外，C++ 还支持其他类型的强制类型转换，如静态类型转换、常量类型转换、向上转型等。</p><p>例如，假设有一个名为 A 的类，它包含一个整型成员 a。如果我们想要将 a 的值转换为浮点型，那么可以使用静态类型转换：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">A</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">public:</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> a;</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">  A obj;</span></span>
<span class="line"><span style="color:#E1E4E8;">  obj.a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">float</span><span style="color:#E1E4E8;"> f </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static_cast&lt;float&gt;</span><span style="color:#E1E4E8;">(obj.a);</span><span style="color:#6A737D;">  // 将 a 的值转换为浮点型</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">A</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#D73A49;">public:</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> a;</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  A obj;</span></span>
<span class="line"><span style="color:#24292E;">  obj.a </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">10</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">float</span><span style="color:#24292E;"> f </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static_cast&lt;float&gt;</span><span style="color:#24292E;">(obj.a);</span><span style="color:#6A737D;">  // 将 a 的值转换为浮点型</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>另外，假设有一个名为 B 的类，它包含一个指向 A 类的指针成员 b。如果我们想要将 b 转换为指向 A 类的常量指针，那么可以使用常量类型转换：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">A</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">public:</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> a;</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">B</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">public:</span></span>
<span class="line"><span style="color:#E1E4E8;">  A</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> b;</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">  A obj;</span></span>
<span class="line"><span style="color:#E1E4E8;">  obj.a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  B b;</span></span>
<span class="line"><span style="color:#E1E4E8;">  b.b </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">obj;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> A</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> p </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">const_cast&lt;const</span><span style="color:#E1E4E8;"> A</span><span style="color:#F97583;">*&gt;</span><span style="color:#E1E4E8;">(b.b);</span><span style="color:#6A737D;">  // 将 b 转换为指向 A 类的常量指针</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">A</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#D73A49;">public:</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> a;</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">B</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#D73A49;">public:</span></span>
<span class="line"><span style="color:#24292E;">  A</span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> b;</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  A obj;</span></span>
<span class="line"><span style="color:#24292E;">  obj.a </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">10</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  B b;</span></span>
<span class="line"><span style="color:#24292E;">  b.b </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;">obj;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> A</span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> p </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">const_cast&lt;const</span><span style="color:#24292E;"> A</span><span style="color:#D73A49;">*&gt;</span><span style="color:#24292E;">(b.b);</span><span style="color:#6A737D;">  // 将 b 转换为指向 A 类的常量指针</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>最后，假设有一个名为 C 的类，它包含一个指针成员 c，该指针指向一个指针。如果我们想要将 c 转换为指向一个整型的指针，那么可以使用向上转型：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">C</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">public:</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">void**</span><span style="color:#E1E4E8;"> c;</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  C obj;</span></span>
<span class="line"><span style="color:#E1E4E8;">  obj.c </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">reinterpret_cast&lt;void**&gt;</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">i);</span><span style="color:#6A737D;">  // 将 c 转换为指向整型的指针</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">C</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#D73A49;">public:</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">void**</span><span style="color:#24292E;"> c;</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">10</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  C obj;</span></span>
<span class="line"><span style="color:#24292E;">  obj.c </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">reinterpret_cast&lt;void**&gt;</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;">i);</span><span style="color:#6A737D;">  // 将 c 转换为指向整型的指针</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>上面是一些简单的例子，它们演示了 C++ 中常用的几种强制类型转换方式。总体来说，强制类型转换是一种有用的工具，它可以帮助我们更方便地进行数据类型转换。不过，我们在使用它们时也需要格外小心，避免破坏数据类型的约定，从而保证程序的正确性和安全性。</p><p>另外，在 C++ 中，我们也可以使用类型擦除来实现类型的转换。类型擦除是指将泛型类型转换为一种通用类型，从而实现类型的转换。例如，假设有一个泛型类型 T，那么我们可以将它转换为 void 类型，从而实现类型擦除：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">template</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">typename</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">MyClass</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">public:</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">doSomething</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">t</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#6A737D;">    // 在 MyClass 中实现的操作</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">  MyClass</span><span style="color:#F97583;">&lt;int&gt;</span><span style="color:#E1E4E8;"> obj1;</span></span>
<span class="line"><span style="color:#E1E4E8;">  obj1.</span><span style="color:#B392F0;">doSomething</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  MyClass</span><span style="color:#F97583;">&lt;float&gt;</span><span style="color:#E1E4E8;"> obj2;</span></span>
<span class="line"><span style="color:#E1E4E8;">  obj2.</span><span style="color:#B392F0;">doSomething</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">3.14</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  MyClass</span><span style="color:#F97583;">&lt;void&gt;</span><span style="color:#E1E4E8;"> obj3;</span></span>
<span class="line"><span style="color:#E1E4E8;">  obj3.</span><span style="color:#B392F0;">doSomething</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">nullptr</span><span style="color:#E1E4E8;">);</span><span style="color:#6A737D;">  // 类型擦除</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">template</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">typename</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">T</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">MyClass</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#D73A49;">public:</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">doSomething</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">T</span><span style="color:#24292E;"> </span><span style="color:#E36209;">t</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#6A737D;">    // 在 MyClass 中实现的操作</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  MyClass</span><span style="color:#D73A49;">&lt;int&gt;</span><span style="color:#24292E;"> obj1;</span></span>
<span class="line"><span style="color:#24292E;">  obj1.</span><span style="color:#6F42C1;">doSomething</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">10</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  MyClass</span><span style="color:#D73A49;">&lt;float&gt;</span><span style="color:#24292E;"> obj2;</span></span>
<span class="line"><span style="color:#24292E;">  obj2.</span><span style="color:#6F42C1;">doSomething</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">3.14</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  MyClass</span><span style="color:#D73A49;">&lt;void&gt;</span><span style="color:#24292E;"> obj3;</span></span>
<span class="line"><span style="color:#24292E;">  obj3.</span><span style="color:#6F42C1;">doSomething</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">nullptr</span><span style="color:#24292E;">);</span><span style="color:#6A737D;">  // 类型擦除</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在上面的例子中，我们定义了一个泛型类 MyClass，然后在 main 函数中创建了三个 MyClass 对象，分别表示 int、float 和 void 类型。然后，我们通过类型擦除，将<code>MyClass&lt;void&gt;</code>对象转换为 void 类型，并调用它的 doSomething 操作。</p><p>总之，在 C++ 中，强制类型转换和类型擦除是两种实现类型转换的重要方式。它们都有各自的优缺点，适用于不同的场景。因此，我们在使用它们时，需要根据具体的情况，仔细斟酌选择合适的方式。</p><h2 id="如何避免循环依赖" tabindex="-1">如何避免循环依赖 <a class="header-anchor" href="#如何避免循环依赖" aria-label="Permalink to &quot;如何避免循环依赖&quot;">​</a></h2><p>循环依赖是指两个或多个模块之间相互依赖，导致它们无法正确加载的情况。解决循环依赖的一种方法是使用抽象类来提供一个公共接口，并让这些模块实现该接口。这样，模块之间就只依赖于这个抽象类，而不是相互依赖。</p><p>另一种方法是使用构造函数来注入依赖。这种方法的思想是将每个模块的依赖作为它的构造函数的参数，然后在每个模块中创建它所依赖的模块的实例。这样，模块之间就不存在直接的依赖关系，只存在通过构造函数传递的间接依赖关系。</p><p>还有一种方法是使用服务定位器模式。该模式涉及到一个中央注册表，所有模块都向该注册表注册自己，然后在需要时从注册表中获取所需的模块实例。这样，模块之间就只存在对注册表的依赖，而不是相互依赖。</p><p>总之，避免循环依赖的方法有很多，具体应用哪种方法取决于您的项目的具体情况。</p><h2 id="unique-ptr中std-move-作用" tabindex="-1">unique_ptr中std::move()作用 <a class="header-anchor" href="#unique-ptr中std-move-作用" aria-label="Permalink to &quot;unique_ptr中std::move()作用&quot;">​</a></h2><p>std::move 是一个 C++ 标准库函数，用于将一个对象的所有权从一个对象转移到另一个对象。它通常用于将一个对象的所有权从一个 std::unique_ptr 对象转移到另一个 std::unique_ptr 对象。</p><p>举个例子，假设有一个 std::unique_ptr 对象 ptr1，它指向一个动态分配的整型变量，值为 10：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::</span><span style="color:#B392F0;">unique_ptr</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#B392F0;">ptr1</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">));</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::</span><span style="color:#6F42C1;">unique_ptr</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">&gt; </span><span style="color:#6F42C1;">ptr1</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">10</span><span style="color:#24292E;">));</span></span></code></pre></div><p>如果您想将 ptr1 的所有权转移到另一个 std::unique_ptr 对象 ptr2 中，可以使用 std::move 函数，如下所示：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::unique_ptr</span><span style="color:#F97583;">&lt;int&gt;</span><span style="color:#E1E4E8;"> ptr2 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::</span><span style="color:#B392F0;">move</span><span style="color:#E1E4E8;">(ptr1);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::unique_ptr</span><span style="color:#D73A49;">&lt;int&gt;</span><span style="color:#24292E;"> ptr2 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::</span><span style="color:#6F42C1;">move</span><span style="color:#24292E;">(ptr1);</span></span></code></pre></div><p>在这种情况下，ptr1 和 ptr2 将指向同一个整型变量，值为 10。不过，由于 std::move 函数将 ptr1 的所有权转移到了 ptr2 中，因此 ptr1 将不再持有任何所有权，所以 ptr1 将变为空指针。</p><p>总之，std::move 函数用于将对象的所有权从一个对象转移到另一个对象，它通常用于 std::unique_ptr 对象之间的所有权转移。</p><h2 id="main函数执行以前-还会执行什么代码-之后呢" tabindex="-1">main函数执行以前，还会执行什么代码？之后呢？ <a class="header-anchor" href="#main函数执行以前-还会执行什么代码-之后呢" aria-label="Permalink to &quot;main函数执行以前，还会执行什么代码？之后呢？&quot;">​</a></h2><p>全局对象的构造函数会在main函数之前执行</p><p>在主函数之前，编译器会执行一些初始化代码，例如初始化全局变量。主函数执行完成后，如果程序中还有其他函数正在运行，那么这些函数会继续执行。一旦所有函数都执行完毕，程序就会结束。</p><h2 id="c-是不是类型安全的" tabindex="-1">C++是不是类型安全的？ <a class="header-anchor" href="#c-是不是类型安全的" aria-label="Permalink to &quot;C++是不是类型安全的？&quot;">​</a></h2><blockquote><p>不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)。C#是类型安全的。</p></blockquote><p>C++是类型安全的编程语言。类型安全是指在编译时对类型的检查，以确保变量的值和它的类型相匹配。这样可以防止在运行时出现错误，比如将一个整型值赋给一个字符型变量。</p><p>除了C++，Java、C#和Haskell等语言也是类型安全的。</p><p>C++ 是一种强类型语言，它对类型有严格的检查，并且支持类型转换。这些特性都可以被看作是类型安全的特征。</p><p>在 C++ 中，不同类型的指针可以互相转换，但是这种转换是非常危险的，因为它可能导致程序运行时出现错误。例如，如果将一个整型指针转换成字符型指针，程序可能会在使用该指针时崩溃。</p><p>因此，在 C++ 中，指针类型的转换可能会绕过类型安全检查，并导致程序出现错误。但是，在大多数情况下，C++ 仍然是一种类型安全的语言，因为它对类型的检查非常严格。如果您的代码涉及指针类型的转换，我建议您格外小心，确保转换是安全的。</p><h2 id="有哪几种情况只能用initialization-list而不能用assignment" tabindex="-1">有哪几种情况只能用initialization list而不能用assignment? <a class="header-anchor" href="#有哪几种情况只能用initialization-list而不能用assignment" aria-label="Permalink to &quot;有哪几种情况只能用initialization list而不能用assignment?&quot;">​</a></h2><p>当类中含const、reference成员变量；基类的构造函数都需要初始化表。</p><h2 id="list-和-set" tabindex="-1">List 和 Set <a class="header-anchor" href="#list-和-set" aria-label="Permalink to &quot;List 和 Set&quot;">​</a></h2><p>List 可以存放相同元素 Set 不可存放相同元素</p><h2 id="写一个http网络服务器-该如何写" tabindex="-1">写一个http网络服务器，该如何写 <a class="header-anchor" href="#写一个http网络服务器-该如何写" aria-label="Permalink to &quot;写一个http网络服务器，该如何写&quot;">​</a></h2><ol><li>包含必要的头文件，例如 <code>&lt;iostream&gt;</code> 和 <code>&lt;string&gt;</code>。</li><li>使用 <code>std::string</code> 类型定义一个字符串，用来存储 HTTP 响应。</li><li>使用 <code>std::cout</code> 向标准输出流中输出 HTTP 响应字符串。</li><li>使用 <code>std::cin</code> 从标准输入流中读取 HTTP 请求，并将其存储在一个字符串中。</li><li>使用字符串函数解析 HTTP 请求，从中提取 URL 和其他必要的信息。</li><li>根据请求的 URL 来选择如何响应请求。例如，如果 URL 指向一个文件，可以读取文件内容并将其作为响应的正文返回。</li><li>构造一个 HTTP 响应字符串，并使用 <code>std::cout</code> 将其输出到标准输出流中。</li></ol><p>为了完成这个项目，您可能需要了解以下技术：</p><ul><li>网络编程：您需要了解如何使用 C++ 库来编写网络应用程序，例如如何使用套接字来连接客户端和服务器。</li><li>HTTP 协议：您需要了解 HTTP 协议的工作原理，包括请求和响应的格式以及如何处理常见的 HTTP 方法（例如 GET 和 POST）。</li><li>多线程编程：为了实现高性能的服务器，您可能需要使用多线程来处理多个请求。您需要了解如何使用 C++ 标准库中的线程类来创建和管理多个线程。</li></ul><p>在实现这个项目时，您可能需要先完成以下步骤：</p><ul><li>创建一个新的 C++ 项目，并包含必要的头文件。</li><li>使用 C++ 标准库中的网络编程库，创建一个新的套接字，并将其绑定到一个特定的端口。</li><li>编写一个函数，用来接收客户端的连接。在这个函数中，您需要创建一个新的线程来处理客户端的请求。</li><li>在新线程中，编写代码来读取客户端发送的 HTTP 请求，并解析其中的 URL。</li></ul><p>以下是一个简单的例子，它展示了如何创建一个网络服务器，并使用多线程来处理客户端请求。</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">#include</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&lt;iostream&gt;</span></span>
<span class="line"><span style="color:#F97583;">#include</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&lt;string&gt;</span></span>
<span class="line"><span style="color:#F97583;">#include</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&lt;thread&gt;</span></span>
<span class="line"><span style="color:#F97583;">#include</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&lt;cstdio&gt;</span></span>
<span class="line"><span style="color:#F97583;">#include</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&lt;cstring&gt;</span></span>
<span class="line"><span style="color:#F97583;">#include</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&lt;cerrno&gt;</span></span>
<span class="line"><span style="color:#F97583;">#include</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&lt;unistd.h&gt;</span></span>
<span class="line"><span style="color:#F97583;">#include</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&lt;sys/socket.h&gt;</span></span>
<span class="line"><span style="color:#F97583;">#include</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&lt;netinet/in.h&gt;</span></span>
<span class="line"><span style="color:#F97583;">#include</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&lt;arpa/inet.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 定义服务器的 IP 地址和端口号</span></span>
<span class="line"><span style="color:#F97583;">constexpr</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">char</span><span style="color:#E1E4E8;"> SERVER_IP[] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;127.0.0.1&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">constexpr</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> SERVER_PORT </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">8080</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 定义缓冲区的大小</span></span>
<span class="line"><span style="color:#F97583;">constexpr</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">size_t</span><span style="color:#E1E4E8;"> BUFFER_SIZE </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1024</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 定义 HTTP 响应字符串</span></span>
<span class="line"><span style="color:#F97583;">constexpr</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">char</span><span style="color:#E1E4E8;"> HTTP_RESPONSE[] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;HTTP/1.1 200 OK</span><span style="color:#79B8FF;">\\r\\n\\r\\n</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 定义处理客户端请求的函数</span></span>
<span class="line"><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">handle_client</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">client_fd</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#6A737D;">  // 创建缓冲区</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">char</span><span style="color:#E1E4E8;"> buffer[BUFFER_SIZE];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">  // 读取客户端发送的请求</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">ssize_t</span><span style="color:#E1E4E8;"> n </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">read</span><span style="color:#E1E4E8;">(client_fd, buffer, </span><span style="color:#F97583;">sizeof</span><span style="color:#E1E4E8;">(buffer));</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (n </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::cerr </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;Error: &quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">strerror</span><span style="color:#E1E4E8;">(errno) </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::endl;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">  // 解析请求中的 URL</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::string </span><span style="color:#B392F0;">request</span><span style="color:#E1E4E8;">(buffer, n);</span></span>
<span class="line"><span style="color:#6A737D;">  // (省略)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">  // 构造 HTTP 响应字符串</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::string response </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> HTTP_RESPONSE;</span></span>
<span class="line"><span style="color:#6A737D;">  // (省略)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">  // 向客户端发送响应</span></span>
<span class="line"><span style="color:#E1E4E8;">  n </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">write</span><span style="color:#E1E4E8;">(client_fd, response.</span><span style="color:#B392F0;">c_str</span><span style="color:#E1E4E8;">(), response.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (n </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::cerr </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;Error: &quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">strerror</span><span style="color:#E1E4E8;">(errno) </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::endl;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">  // 关闭客户端的连接</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">close</span><span style="color:#E1E4E8;">(client_fd);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">argc</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">char*</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">argv</span><span style="color:#E1E4E8;">[]) {</span></span>
<span class="line"><span style="color:#6A737D;">  // 解析命令行参数</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> opt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">bool</span><span style="color:#E1E4E8;"> server_running </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> ((opt </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getopt</span><span style="color:#E1E4E8;">(argc, argv, </span><span style="color:#9ECBFF;">&quot;h&quot;</span><span style="color:#E1E4E8;">)) </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">switch</span><span style="color:#E1E4E8;"> (opt) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;h&#39;</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#6A737D;">        // 打印帮助信息</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">print_usage</span><span style="color:#E1E4E8;">(argv[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">]);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">default</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::cerr </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;Error: Invalid option &quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> opt </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::endl;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">print_usage</span><span style="color:#E1E4E8;">(argv[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">]);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">  // 创建一个新的套接字</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> sock_fd </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">socket</span><span style="color:#E1E4E8;">(AF_INET, SOCK_STREAM, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (sock_fd </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::cerr </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;Error: &quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">strerror</span><span style="color:#E1E4E8;">(errno) </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::endl;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">  // 填充服务器的地址信息</span></span>
<span class="line"><span style="color:#E1E4E8;">  sockaddr_in server_addr;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::</span><span style="color:#B392F0;">memset</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">server_addr, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">sizeof</span><span style="color:#E1E4E8;">(server_addr));</span></span>
<span class="line"><span style="color:#E1E4E8;">  server_addr.sin_family </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> AF_INET;</span></span>
<span class="line"><span style="color:#E1E4E8;">  server_addr.sin_port </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">htons</span><span style="color:#E1E4E8;">(SERVER_PORT);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">inet_pton</span><span style="color:#E1E4E8;">(AF_INET, SERVER_IP, </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">server_addr.sin_addr);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">  // 绑定套接字</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">bind</span><span style="color:#E1E4E8;">(sock_fd, (sockaddr</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">server_addr, </span><span style="color:#F97583;">sizeof</span><span style="color:#E1E4E8;">(server_addr)) </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::cerr </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;Error: &quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">strerror</span><span style="color:#E1E4E8;">(errno) </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::endl;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">  // 开始监听</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">listen</span><span style="color:#E1E4E8;">(sock_fd, SOMAXCONN) </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::cerr </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;Error: &quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">strerror</span><span style="color:#E1E4E8;">(errno) </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::endl;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">  // 注册信号处理器</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">signal</span><span style="color:#E1E4E8;">(SIGINT, [](</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">){ server_running </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">; });</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">  // 使用死循环来接收客户端的连接</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (server_running) {</span></span>
<span class="line"><span style="color:#6A737D;">    // 接收客户端的连接</span></span>
<span class="line"><span style="color:#E1E4E8;">    sockaddr_in client_addr;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">socklen_t</span><span style="color:#E1E4E8;"> client_addr_len </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">sizeof</span><span style="color:#E1E4E8;">(client_addr);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> client_fd </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">accept</span><span style="color:#E1E4E8;">(sock_fd, (sockaddr</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">client_addr, </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">client_addr_len);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (client_fd </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::cerr </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;Error: &quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">strerror</span><span style="color:#E1E4E8;">(errno) </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::endl;</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">continue</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">    // 为客户端创建一个新的线程来处理请求</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::thread </span><span style="color:#B392F0;">client_thread</span><span style="color:#E1E4E8;">(handle_client, client_fd);</span></span>
<span class="line"><span style="color:#E1E4E8;">    client_thread.</span><span style="color:#B392F0;">detach</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">  // 关闭套接字</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">close</span><span style="color:#E1E4E8;">(sock_fd);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">#include</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&lt;iostream&gt;</span></span>
<span class="line"><span style="color:#D73A49;">#include</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&lt;string&gt;</span></span>
<span class="line"><span style="color:#D73A49;">#include</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&lt;thread&gt;</span></span>
<span class="line"><span style="color:#D73A49;">#include</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&lt;cstdio&gt;</span></span>
<span class="line"><span style="color:#D73A49;">#include</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&lt;cstring&gt;</span></span>
<span class="line"><span style="color:#D73A49;">#include</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&lt;cerrno&gt;</span></span>
<span class="line"><span style="color:#D73A49;">#include</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&lt;unistd.h&gt;</span></span>
<span class="line"><span style="color:#D73A49;">#include</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&lt;sys/socket.h&gt;</span></span>
<span class="line"><span style="color:#D73A49;">#include</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&lt;netinet/in.h&gt;</span></span>
<span class="line"><span style="color:#D73A49;">#include</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&lt;arpa/inet.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 定义服务器的 IP 地址和端口号</span></span>
<span class="line"><span style="color:#D73A49;">constexpr</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">char</span><span style="color:#24292E;"> SERVER_IP[] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;127.0.0.1&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">constexpr</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> SERVER_PORT </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">8080</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 定义缓冲区的大小</span></span>
<span class="line"><span style="color:#D73A49;">constexpr</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">size_t</span><span style="color:#24292E;"> BUFFER_SIZE </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1024</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 定义 HTTP 响应字符串</span></span>
<span class="line"><span style="color:#D73A49;">constexpr</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">char</span><span style="color:#24292E;"> HTTP_RESPONSE[] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;HTTP/1.1 200 OK</span><span style="color:#005CC5;">\\r\\n\\r\\n</span><span style="color:#032F62;">&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 定义处理客户端请求的函数</span></span>
<span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">handle_client</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">client_fd</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#6A737D;">  // 创建缓冲区</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">char</span><span style="color:#24292E;"> buffer[BUFFER_SIZE];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">  // 读取客户端发送的请求</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">ssize_t</span><span style="color:#24292E;"> n </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">read</span><span style="color:#24292E;">(client_fd, buffer, </span><span style="color:#D73A49;">sizeof</span><span style="color:#24292E;">(buffer));</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (n </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::cerr </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;Error: &quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">strerror</span><span style="color:#24292E;">(errno) </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::endl;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">  // 解析请求中的 URL</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::string </span><span style="color:#6F42C1;">request</span><span style="color:#24292E;">(buffer, n);</span></span>
<span class="line"><span style="color:#6A737D;">  // (省略)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">  // 构造 HTTP 响应字符串</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::string response </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> HTTP_RESPONSE;</span></span>
<span class="line"><span style="color:#6A737D;">  // (省略)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">  // 向客户端发送响应</span></span>
<span class="line"><span style="color:#24292E;">  n </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">write</span><span style="color:#24292E;">(client_fd, response.</span><span style="color:#6F42C1;">c_str</span><span style="color:#24292E;">(), response.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (n </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::cerr </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;Error: &quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">strerror</span><span style="color:#24292E;">(errno) </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::endl;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">  // 关闭客户端的连接</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">close</span><span style="color:#24292E;">(client_fd);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">argc</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">char*</span><span style="color:#24292E;"> </span><span style="color:#E36209;">argv</span><span style="color:#24292E;">[]) {</span></span>
<span class="line"><span style="color:#6A737D;">  // 解析命令行参数</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> opt;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">bool</span><span style="color:#24292E;"> server_running </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> ((opt </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getopt</span><span style="color:#24292E;">(argc, argv, </span><span style="color:#032F62;">&quot;h&quot;</span><span style="color:#24292E;">)) </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">switch</span><span style="color:#24292E;"> (opt) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;h&#39;</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#6A737D;">        // 打印帮助信息</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">print_usage</span><span style="color:#24292E;">(argv[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">]);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">default</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::cerr </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;Error: Invalid option &quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> opt </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::endl;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">print_usage</span><span style="color:#24292E;">(argv[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">]);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">  // 创建一个新的套接字</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> sock_fd </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">socket</span><span style="color:#24292E;">(AF_INET, SOCK_STREAM, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (sock_fd </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::cerr </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;Error: &quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">strerror</span><span style="color:#24292E;">(errno) </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::endl;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">  // 填充服务器的地址信息</span></span>
<span class="line"><span style="color:#24292E;">  sockaddr_in server_addr;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::</span><span style="color:#6F42C1;">memset</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;">server_addr, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">sizeof</span><span style="color:#24292E;">(server_addr));</span></span>
<span class="line"><span style="color:#24292E;">  server_addr.sin_family </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> AF_INET;</span></span>
<span class="line"><span style="color:#24292E;">  server_addr.sin_port </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">htons</span><span style="color:#24292E;">(SERVER_PORT);</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">inet_pton</span><span style="color:#24292E;">(AF_INET, SERVER_IP, </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;">server_addr.sin_addr);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">  // 绑定套接字</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">bind</span><span style="color:#24292E;">(sock_fd, (sockaddr</span><span style="color:#D73A49;">*</span><span style="color:#24292E;">)</span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;">server_addr, </span><span style="color:#D73A49;">sizeof</span><span style="color:#24292E;">(server_addr)) </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::cerr </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;Error: &quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">strerror</span><span style="color:#24292E;">(errno) </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::endl;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">  // 开始监听</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">listen</span><span style="color:#24292E;">(sock_fd, SOMAXCONN) </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::cerr </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;Error: &quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">strerror</span><span style="color:#24292E;">(errno) </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::endl;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">  // 注册信号处理器</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">signal</span><span style="color:#24292E;">(SIGINT, [](</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">){ server_running </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">; });</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">  // 使用死循环来接收客户端的连接</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (server_running) {</span></span>
<span class="line"><span style="color:#6A737D;">    // 接收客户端的连接</span></span>
<span class="line"><span style="color:#24292E;">    sockaddr_in client_addr;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">socklen_t</span><span style="color:#24292E;"> client_addr_len </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">sizeof</span><span style="color:#24292E;">(client_addr);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> client_fd </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">accept</span><span style="color:#24292E;">(sock_fd, (sockaddr</span><span style="color:#D73A49;">*</span><span style="color:#24292E;">)</span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;">client_addr, </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;">client_addr_len);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (client_fd </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::cerr </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;Error: &quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">strerror</span><span style="color:#24292E;">(errno) </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::endl;</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">continue</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">    // 为客户端创建一个新的线程来处理请求</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::thread </span><span style="color:#6F42C1;">client_thread</span><span style="color:#24292E;">(handle_client, client_fd);</span></span>
<span class="line"><span style="color:#24292E;">    client_thread.</span><span style="color:#6F42C1;">detach</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">  // 关闭套接字</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">close</span><span style="color:#24292E;">(sock_fd);</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>除了上述的步骤之外，您还可以考虑以下优化：</p><ul><li>设置套接字的选项，例如 SO_REUSEADDR 和 SO_REUSEPORT，以提高服务器的性能。</li><li>使用 epoll 或 select 等 I/O 多路复用技术来支持多个客户端的并发访问。</li><li>使用线程池来管理线程，而不是每次创建一个新的线程。</li><li>使用缓存来存储客户端请求的内容，以提高服务器的响应速度。</li></ul><h2 id="谈一谈-c-的-this" tabindex="-1">谈一谈 c++ 的 this <a class="header-anchor" href="#谈一谈-c-的-this" aria-label="Permalink to &quot;谈一谈 c++ 的 this&quot;">​</a></h2><p><a href="https://zintrulcre.vip/posts/cpp/closure-and-anonymous-function/" target="_blank" rel="noreferrer">匿名函数</a></p><h2 id="不同类型的语言有什么差异" tabindex="-1">不同类型的语言有什么差异 <a class="header-anchor" href="#不同类型的语言有什么差异" aria-label="Permalink to &quot;不同类型的语言有什么差异&quot;">​</a></h2><p>::callout #summary 自然语言 #content 不同类型的语言有很多差异，包括它们的语法、词汇和发音方式。例如，拉丁语和汉语是两种非常不同的语言，它们的语法和词汇都大不相同。拉丁语是一种重音语言，它的词语通常是以重读音节结尾的，而汉语则是一种声调语言，词语的意思取决于它的声调。此外，拉丁语和汉语在语音方面也有很大差异，拉丁语的语音比较清脆，而汉语的语音则比较柔和。总之，不同类型的语言在许多方面都有所不同，包括它们的语法、词汇和发音方式。 ::</p><p>这些差异主要体现在它们的语法、语义、功能和性能方面。例如，C++和Python是两种非常不同的编程语言。C++是一种类型严格的语言，它的语法比较严谨，需要程序员明确地指定每一个变量的类型，而Python是一种类型动态的语言，它的语法比较灵活，不需要程序员指定变量的类型。此外，C++在性能方面比Python要优秀得多，因为它是一种编译型语言，在运行时会被编译成机器代码，而Python则是一种解释型语言，它的代码在运行时会被解释器逐行执行。总之，不同类型的编程语言在语法、语义、功能和性能方面都有所不同，程序员可以根据自己的需要选择合适的语言来开发自己的程序。</p><h2 id="如何优化冒泡排序" tabindex="-1">如何优化冒泡排序 <a class="header-anchor" href="#如何优化冒泡排序" aria-label="Permalink to &quot;如何优化冒泡排序&quot;">​</a></h2><p>冒泡排序是一种简单但不够高效的排序算法。为了优化冒泡排序，我们可以采用以下技术：</p><ol><li>每次冒泡时，将最大值移动到数组末尾，并逐渐缩小冒泡范围。这样，每次冒泡时只需要比较一部分数组元素，可以大大减少冒泡次数，提高排序效率。</li><li>在每次冒泡时，记录最后一次交换的位置。这个位置之后的元素都已经有序，因此可以在下一次冒泡时跳过这些元素，减少无用的比较次数。</li><li>在冒泡过程中，如果发现某一轮冒泡没有发生任何交换，那么说明数组已经有序，可以提前结束排序。</li></ol><p>通过以上技术，我们可以大大优化冒泡排序的性能，使它能够更快地完成排序任务。</p>`,113),e=[o];function c(t,r,E,y,i,d){return a(),n("div",null,e)}const h=s(p,[["render",c]]);export{u as __pageData,h as default};

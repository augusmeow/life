import{_ as e,c as t,a3 as i,o}from"./chunks/framework.DDs3IadZ.js";const b=JSON.parse('{"title":"gcc","description":"","frontmatter":{"icon":"twemoji:building-construction"},"headers":[],"relativePath":"code/cpp/compile/gcc.md","filePath":"code/cpp/compile/gcc.md","lastUpdated":1716791141000}'),d={name:"code/cpp/compile/gcc.md"};function r(c,a,l,n,h,s){return o(),t("div",null,a[0]||(a[0]=[i(`<h1 id="gcc" tabindex="-1">gcc <a class="header-anchor" href="#gcc" aria-label="Permalink to &quot;gcc&quot;">​</a></h1><h2 id="介绍" tabindex="-1">介绍 <a class="header-anchor" href="#介绍" aria-label="Permalink to &quot;介绍&quot;">​</a></h2><p><a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html" target="_blank" rel="noreferrer">版本对应</a></p><p><code>gcc</code> 与 <code>g++</code> 分别是 <code>gnu</code> 的 <code>c/c++</code> 编译器 <code>gcc/g++</code> 在执行编译工作的时候，总共需要4步：</p><ol><li>预处理, 生成 .i 的文件[预处理器cpp]</li><li>将预处理后的文件转换成汇编语言, 生成文件 .s [编译器egcs]</li><li>有汇编变为目标代码(机器代码)生成 .o 的文件[汇编器as]</li><li>连接目标代码, 生成可执行程序 [链接器ld]</li></ol><h2 id="加速编译" tabindex="-1">加速编译 <a class="header-anchor" href="#加速编译" aria-label="Permalink to &quot;加速编译&quot;">​</a></h2><ol><li><code>-O2</code>：启用级别为2的优化，通常能提高代码的运行速度。</li><li><code>-pipe</code>：使用管道连接操作，避免将文件写入磁盘，从而提高编译速度。</li><li><code>-j</code>：指定并行编译数，如-j4表示使用4个线程并行编译。</li><li><code>-fno-exceptions</code> 和 <code>-fno-rtti</code>：禁用C++异常和运行时类型信息，可以加速编译和减小代码体积。</li><li><code>-flto</code>：启用链接时优化，将多个源文件编译成单个目标文件，可以提高代码性能。</li><li><code>-fprofile-generate</code> 和 <code>-fprofile-use</code>：启用代码覆盖率统计，可以更好地优化代码。</li><li><code>-Wno-unused-but-set-parameter</code>：禁用参数初始化警告，可以减小编译时间。</li></ol><h2 id="gcc-命令的常用选项" tabindex="-1">gcc 命令的常用选项 <a class="header-anchor" href="#gcc-命令的常用选项" aria-label="Permalink to &quot;gcc 命令的常用选项&quot;">​</a></h2><table tabindex="0"><thead><tr><th>选项</th><th>解释</th></tr></thead><tbody><tr><td><code>-ansi</code></td><td>只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。</td></tr><tr><td><code>-c</code></td><td>只编译并生成目标文件。</td></tr><tr><td><code>-DMACRO</code></td><td>以字符串&quot;1&quot;定义 MACRO 宏。</td></tr><tr><td><code>-DMACRO=DEFN</code></td><td>以字符串&quot;DEFN&quot;定义 MACRO 宏。</td></tr><tr><td><code>-E</code></td><td>只运行 C 预编译器。</td></tr><tr><td><code>-g</code></td><td>生成调试信息。GNU 调试器可利用该信息。</td></tr><tr><td><code>-IDIRECTORY</code></td><td>指定额外的头文件搜索路径DIRECTORY。</td></tr><tr><td><code>-LDIRECTORY</code></td><td>指定额外的函数库搜索路径DIRECTORY。</td></tr><tr><td><code>-lLIBRARY</code></td><td>连接时搜索指定的函数库LIBRARY。</td></tr><tr><td><code>-m486</code></td><td>针对 486 进行代码优化。</td></tr><tr><td><code>-o FILE</code></td><td>生成指定的输出文件。用在生成可执行文件时。</td></tr><tr><td><code>-O0</code></td><td>不进行优化处理。</td></tr><tr><td><code>-O</code> 或 <code>-O1</code></td><td>优化生成代码。</td></tr><tr><td><code>-O2</code></td><td>进一步优化。</td></tr><tr><td><code>-O3</code></td><td>比 -O2 更进一步优化，包括 inline 函数。</td></tr><tr><td><code>-shared</code></td><td>生成共享目标文件。通常用在建立共享库时。</td></tr><tr><td><code>-static</code></td><td>禁止使用共享连接。</td></tr><tr><td><code>-UMACRO</code></td><td>取消对 MACRO 宏的定义。</td></tr><tr><td><code>-w</code></td><td>不生成任何警告信息。</td></tr><tr><td><code>-Wall</code></td><td>生成所有警告信息。</td></tr><tr><td><code>-Werror</code></td><td>表示把所有的警告信息变成编译错误（即警告信息会导致编译失败）</td></tr><tr><td><code>-Wl,-Bstatic</code></td><td>告诉编译器使用静态库链接方式(直到遇到别的标记)</td></tr><tr><td><code>-Wl,-Bdynamic</code></td><td>告诉编译器使用动态库链接方式</td></tr><tr><td><code>-ldl</code></td><td>链接动态链接库加载器库</td></tr></tbody></table><h2 id="参数详解" tabindex="-1">参数详解 <a class="header-anchor" href="#参数详解" aria-label="Permalink to &quot;参数详解&quot;">​</a></h2><h3 id="x-language-filename" tabindex="-1">-x language filename <a class="header-anchor" href="#x-language-filename" aria-label="Permalink to &quot;-x language filename&quot;">​</a></h3><p>设定文件所使用的语言, 使后缀名无效, 对以后的多个有效。也就是根据约定 C 语言的后缀名称是 .c 的，而 C++ 的后缀名是 .C 或者 .cpp, 如果你很个性，决定你的 C 代码文件的后缀名是 .pig 哈哈，那你就要用这个参数, 这个参数对他后面的文件名都起作用，除非到了下一个参数的使用。 可以使用的参数吗有下面的这些：&#39;c&#39;, &#39;objective-c&#39;, &#39;c-header&#39;, &#39;c++&#39;, &#39;cpp-output&#39;, &#39;assembler&#39;, 与 &#39;assembler-with-cpp&#39;。<br> 看到英文，应该可以理解的。<br> 例子用法:<br><code>gcc -x c hello.pig</code></p><h3 id="x-none-filename" tabindex="-1">-x none filename <a class="header-anchor" href="#x-none-filename" aria-label="Permalink to &quot;-x none filename&quot;">​</a></h3><p>关掉上一个选项，也就是让gcc根据文件名后缀，自动识别文件类型 。<br> 例子用法:<br><code>gcc -x c hello.pig -x none hello2.c</code></p><h3 id="c" tabindex="-1">-c <a class="header-anchor" href="#c" aria-label="Permalink to &quot;-c&quot;">​</a></h3><p>只激活预处理,编译,和汇编,也就是他只把程序做成obj文件<br> 例子用法:<br><code>gcc -c hello.c</code><br> 他将生成 .o 的 obj 文件</p><h3 id="s" tabindex="-1">-S <a class="header-anchor" href="#s" aria-label="Permalink to &quot;-S&quot;">​</a></h3><p>只激活预处理和编译，就是指把文件编译成为汇编代码。<br> 例子用法:<br><code>gcc -S hello.c</code><br> 他将生成 .s 的汇编代码，你可以用文本编辑器察看。</p><h3 id="e" tabindex="-1">-E <a class="header-anchor" href="#e" aria-label="Permalink to &quot;-E&quot;">​</a></h3><p>只激活预处理,这个不生成文件, 你需要把它重定向到一个输出文件里面。<br> 例子用法:<br><code>gcc -E hello.c &gt; pianoapan.txt</code><br><code>gcc -E hello.c | more</code><br> 慢慢看吧, 一个 hello word 也要与处理成800行的代码。</p><h3 id="o" tabindex="-1">-o <a class="header-anchor" href="#o" aria-label="Permalink to &quot;-o&quot;">​</a></h3><p>制定目标名称, 默认的时候, gcc 编译出来的文件是 a.out, 很难听, 如果你和我有同感，改掉它, 哈哈。<br> 例子用法:</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">gcc</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -o</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> hello.exe</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> hello.c</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> #(哦,windows用习惯了) </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">　　gcc</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -o</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> hello.asm</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -S</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> hello.c</span></span></code></pre></div><h3 id="pipe" tabindex="-1">-pipe <a class="header-anchor" href="#pipe" aria-label="Permalink to &quot;-pipe&quot;">​</a></h3><p>使用管道代替编译中临时文件, 在使用非 gnu 汇编工具的时候, 可能有些问题。<br><code>gcc -pipe -o hello.exe hello.c</code></p><h3 id="ansi" tabindex="-1">-ansi <a class="header-anchor" href="#ansi" aria-label="Permalink to &quot;-ansi&quot;">​</a></h3><p>关闭 gnu c中与 ansi c 不兼容的特性, 激活 ansi c 的专有特性（包括禁止一些 asm inline typeof 关键字, 以及 UNIX,vax 等预处理宏）。</p><h3 id="fno-asm" tabindex="-1">-fno-asm <a class="header-anchor" href="#fno-asm" aria-label="Permalink to &quot;-fno-asm&quot;">​</a></h3><p>此选项实现 ansi 选项的功能的一部分，它禁止将 asm, inline 和 typeof 用作关键字。</p><h3 id="fno-strict-prototype" tabindex="-1">-fno-strict-prototype <a class="header-anchor" href="#fno-strict-prototype" aria-label="Permalink to &quot;-fno-strict-prototype&quot;">​</a></h3><p>只对 g++ 起作用, 使用这个选项, g++ 将对不带参数的函数,都认为是没有显式的对参数的个数和类型说明,而不是没有参数。<br> 而 gcc 无论是否使用这个参数, 都将对没有带参数的函数, 认为城没有显式说明的类型。</p><h3 id="fthis-is-varialble" tabindex="-1">-fthis-is-varialble <a class="header-anchor" href="#fthis-is-varialble" aria-label="Permalink to &quot;-fthis-is-varialble&quot;">​</a></h3><p>就是向传统 c++ 看齐, 可以使用 this 当一般变量使用。</p><h3 id="fcond-mismatch" tabindex="-1">-fcond-mismatch <a class="header-anchor" href="#fcond-mismatch" aria-label="Permalink to &quot;-fcond-mismatch&quot;">​</a></h3><p>允许条件表达式的第二和第三参数类型不匹配, 表达式的值将为 void 类型。</p><h3 id="funsigned-char-、-fno-signed-char、-fsigned-char-、-fno-unsigned-char" tabindex="-1">-funsigned-char 、-fno-signed-char、-fsigned-char 、-fno-unsigned-char <a class="header-anchor" href="#funsigned-char-、-fno-signed-char、-fsigned-char-、-fno-unsigned-char" aria-label="Permalink to &quot;-funsigned-char 、-fno-signed-char、-fsigned-char 、-fno-unsigned-char&quot;">​</a></h3><p>这四个参数是对 char 类型进行设置, 决定将 char 类型设置成 unsigned char(前两个参数)或者 signed char(后两个参数)。</p><h3 id="include-file" tabindex="-1">-include file <a class="header-anchor" href="#include-file" aria-label="Permalink to &quot;-include file&quot;">​</a></h3><p>包含某个代码,简单来说,就是便以某个文件,需要另一个文件的时候,就可以用它设定,功能就相当于在代码中使用 <code>#include&lt;filename&gt;</code>。<br> 例子用法: <code>gcc hello.c -include /root/pianopan.h</code></p><h3 id="imacros-file" tabindex="-1">-imacros file <a class="header-anchor" href="#imacros-file" aria-label="Permalink to &quot;-imacros file&quot;">​</a></h3><p>将 file 文件的宏, 扩展到 gcc/g++ 的输入文件, 宏定义本身并不出现在输入文件中。</p><h3 id="dmacro" tabindex="-1">-Dmacro <a class="header-anchor" href="#dmacro" aria-label="Permalink to &quot;-Dmacro&quot;">​</a></h3><p>相当于 C 语言中的 #define macro</p><h3 id="dmacro-defn" tabindex="-1">-Dmacro=defn <a class="header-anchor" href="#dmacro-defn" aria-label="Permalink to &quot;-Dmacro=defn&quot;">​</a></h3><p>相当于 C 语言中的 #define macro=defn</p><h3 id="umacro" tabindex="-1">-Umacro <a class="header-anchor" href="#umacro" aria-label="Permalink to &quot;-Umacro&quot;">​</a></h3><p>相当于 C 语言中的 #undef macro</p><h3 id="undef" tabindex="-1">-undef <a class="header-anchor" href="#undef" aria-label="Permalink to &quot;-undef&quot;">​</a></h3><p>取消对任何非标准宏的定义</p><h3 id="idir" tabindex="-1">-Idir <a class="header-anchor" href="#idir" aria-label="Permalink to &quot;-Idir&quot;">​</a></h3><p>在你是用 <code>#include &quot;file&quot;</code> 的时候, gcc/g++ 会先在当前目录查找你所制定的头文件, 如果没有找到, 他回到默认的头文件目录找, 如果使用 -I 制定了目录,他会先在你所制定的目录查找, 然后再按常规的顺序去找。<br> 对于 <code>#include&lt;file&gt;</code>, gcc/g++ 会到 -I 制定的目录查找, 查找不到, 然后将到系统的默认的头文件目录查找 。</p><h3 id="i" tabindex="-1">-I- <a class="header-anchor" href="#i" aria-label="Permalink to &quot;-I-&quot;">​</a></h3><p>就是取消前一个参数的功能, 所以一般在 <code>-Idir</code> 之后使用。</p><h3 id="idirafter-dir" tabindex="-1">-idirafter dir <a class="header-anchor" href="#idirafter-dir" aria-label="Permalink to &quot;-idirafter dir&quot;">​</a></h3><p>在 -I 的目录里面查找失败, 讲到这个目录里面查找。</p><h3 id="iprefix-prefix-、-iwithprefix-dir" tabindex="-1">-iprefix prefix 、-iwithprefix dir <a class="header-anchor" href="#iprefix-prefix-、-iwithprefix-dir" aria-label="Permalink to &quot;-iprefix prefix 、-iwithprefix dir&quot;">​</a></h3><p>一般一起使用, 当 -I 的目录查找失败, 会到 prefix+dir 下查找</p><h3 id="nostdinc" tabindex="-1">-nostdinc <a class="header-anchor" href="#nostdinc" aria-label="Permalink to &quot;-nostdinc&quot;">​</a></h3><p>使编译器不再系统默认的头文件目录里面找头文件, 一般和 -I 联合使用,明确限定头文件的位置。</p><h3 id="nostdin-c" tabindex="-1">-nostdin C++ <a class="header-anchor" href="#nostdin-c" aria-label="Permalink to &quot;-nostdin C++&quot;">​</a></h3><p>规定不在 g++ 指定的标准路经中搜索, 但仍在其他路径中搜索, 此选项在创 libg++ 库使用 。</p><h3 id="c-1" tabindex="-1">-C <a class="header-anchor" href="#c-1" aria-label="Permalink to &quot;-C&quot;">​</a></h3><p>在预处理的时候, 不删除注释信息, 一般和-E使用, 有时候分析程序，用这个很方便的。</p><h3 id="m" tabindex="-1">-M <a class="header-anchor" href="#m" aria-label="Permalink to &quot;-M&quot;">​</a></h3><p>生成文件关联的信息。包含目标文件所依赖的所有源代码你可以用 gcc -M hello.c 来测试一下，很简单。</p><h3 id="mm" tabindex="-1">-MM <a class="header-anchor" href="#mm" aria-label="Permalink to &quot;-MM&quot;">​</a></h3><p>和上面的那个一样，但是它将忽略由 <code>#include&lt;file&gt;</code> 造成的依赖关系。</p><h3 id="md" tabindex="-1">-MD <a class="header-anchor" href="#md" aria-label="Permalink to &quot;-MD&quot;">​</a></h3><p>和-M相同，但是输出将导入到.d的文件里面</p><h3 id="mmd" tabindex="-1">-MMD <a class="header-anchor" href="#mmd" aria-label="Permalink to &quot;-MMD&quot;">​</a></h3><p>和 -MM 相同，但是输出将导入到 .d 的文件里面。</p><h3 id="wa-option" tabindex="-1">-Wa,option <a class="header-anchor" href="#wa-option" aria-label="Permalink to &quot;-Wa,option&quot;">​</a></h3><p>此选项传递 option 给汇编程序; 如果 option 中间有逗号, 就将 option 分成多个选项, 然 后传递给会汇编程序。</p><h3 id="wl-option" tabindex="-1">-Wl.option <a class="header-anchor" href="#wl-option" aria-label="Permalink to &quot;-Wl.option&quot;">​</a></h3><p>此选项传递 option 给连接程序; 如果 option 中间有逗号, 就将 option 分成多个选项, 然 后传递给会连接程序。</p><h3 id="llibrary" tabindex="-1">-llibrary <a class="header-anchor" href="#llibrary" aria-label="Permalink to &quot;-llibrary&quot;">​</a></h3><p>制定编译的时候使用的库<br> 例子用法<br><code>gcc -lcurses hello.c</code> 　　 使用 ncurses 库编译程序</p><h3 id="ldir" tabindex="-1">-Ldir <a class="header-anchor" href="#ldir" aria-label="Permalink to &quot;-Ldir&quot;">​</a></h3><p>制定编译的时候，搜索库的路径。比如你自己的库，可以用它制定目录，不然编译器将只在标准库的目录找。这个dir就是目录的名称。</p><h3 id="o0-、-o1-、-o2-、-o3" tabindex="-1">-O0 、-O1 、-O2 、-O3 <a class="header-anchor" href="#o0-、-o1-、-o2-、-o3" aria-label="Permalink to &quot;-O0 、-O1 、-O2 、-O3&quot;">​</a></h3><p>编译器的优化选项的 4 个级别，-O0 表示没有优化, -O1 为默认值，-O3 优化级别最高。</p><h3 id="g" tabindex="-1">-g <a class="header-anchor" href="#g" aria-label="Permalink to &quot;-g&quot;">​</a></h3><p>只是编译器，在编译的时候，产生调试信息。</p><h3 id="gstabs" tabindex="-1">-gstabs <a class="header-anchor" href="#gstabs" aria-label="Permalink to &quot;-gstabs&quot;">​</a></h3><p>此选项以 stabs 格式声称调试信息, 但是不包括 gdb 调试信息。</p><h3 id="gstabs-1" tabindex="-1">-gstabs+ <a class="header-anchor" href="#gstabs-1" aria-label="Permalink to &quot;-gstabs+&quot;">​</a></h3><p>此选项以 stabs 格式声称调试信息, 并且包含仅供 gdb 使用的额外调试信息。</p><h3 id="ggdb" tabindex="-1">-ggdb <a class="header-anchor" href="#ggdb" aria-label="Permalink to &quot;-ggdb&quot;">​</a></h3><p>此选项将尽可能的生成 gdb 的可以使用的调试信息。</p><h3 id="static" tabindex="-1">-static <a class="header-anchor" href="#static" aria-label="Permalink to &quot;-static&quot;">​</a></h3><p>此选项将禁止使用动态库，所以，编译出来的东西，一般都很大，也不需要什么动态连接库，就可以运行。</p><h3 id="share" tabindex="-1">-share <a class="header-anchor" href="#share" aria-label="Permalink to &quot;-share&quot;">​</a></h3><p>此选项将尽量使用动态库，所以生成文件比较小，但是需要系统由动态库。</p><h3 id="traditional" tabindex="-1">-traditional <a class="header-anchor" href="#traditional" aria-label="Permalink to &quot;-traditional&quot;">​</a></h3><p>试图让编译器支持传统的C语言特性。</p><p>GCC 是 GNU 的 C 和 C++ 编译器。实际上，GCC 能够编译三种语言：C、C++ 和 Object C（C 语言的一种面向对象扩展）。利用 gcc 命令可同时编译并连接 C 和 C++ 源程序。<br> 如果你有两个或少数几个 C 源文件，也可以方便地利用 GCC 编译、连接并生成可执行文件。</p>`,96)]))}const u=e(d,[["render",r]]);export{b as __pageData,u as default};

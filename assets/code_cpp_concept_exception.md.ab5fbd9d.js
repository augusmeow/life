import{_ as e,c as a,o as t,Q as i}from"./chunks/framework.1cc28bed.js";const I=JSON.parse('{"title":"异常","description":"","frontmatter":{},"headers":[],"relativePath":"code/cpp/concept/exception.md","filePath":"code/cpp/concept/exception.md","lastUpdated":1682241312000}'),l={name:"code/cpp/concept/exception.md"},o=i('<h1 id="异常" tabindex="-1">异常 <a class="header-anchor" href="#异常" aria-label="Permalink to &quot;异常&quot;">​</a></h1><p>在实际的 C++ 开发中，我们经常会遇到诸如程序运行中突然崩溃、程序运行所用内存越来越多最终不得不重启等问题，这些问题往往都是内存资源管理不当造成的。比如：</p><ul><li>有些内存资源已经被释放，但指向它的指针并没有改变指向（成为了野指针），并且后续还在使用；</li><li>有些内存资源已经被释放，后期又试图再释放一次（重复释放同一块内存会导致程序运行崩溃）；</li><li>没有及时释放不再使用的内存资源，造成内存泄漏，程序占用的内存资源越来越多。</li></ul><h2 id="如何确保对象在抛出异常时也能被删除-什么是raii" tabindex="-1">如何确保对象在抛出异常时也能被删除？什么是RAII？ <a class="header-anchor" href="#如何确保对象在抛出异常时也能被删除-什么是raii" aria-label="Permalink to &quot;如何确保对象在抛出异常时也能被删除？什么是RAII？&quot;">​</a></h2><p>总的思想是RAII：设计一个class，令他的构造函数和析构函数分别获取和释放资源。 有两个方法：</p><ul><li>利用“函数的局部对象无论函数以何种方式(包括因异常)结束都会被析构”这一特性，将“一定要释放的资源”放进局部对象的析构函数；</li><li>使用智能指针。</li></ul><h2 id="如何避免内存泄漏" tabindex="-1">如何避免内存泄漏 <a class="header-anchor" href="#如何避免内存泄漏" aria-label="Permalink to &quot;如何避免内存泄漏&quot;">​</a></h2><ul><li>使用智能指针。C++中的智能指针是一种特殊的指针，它可以自动管理分配的内存，在智能指针超出作用域时自动释放内存，因此可以避免内存泄漏。C++11标准引入了标准库中的unique_ptr和shared_ptr两种智能指针类型，程序员可以使用这两种智能指针来管理内存。</li><li>使用RAII技术。RAII（Resource Acquisition Is Initialization，资源获取即初始化）是一种编程技术，它在对象构造时获取资源（例如内存），在对象析构时释放资源，从而避免内存泄漏。在C++中，程序员可以使用类的构造函数和析构函数来实现RAII技术。</li><li>严格控制内存分配与释放。如果不能使用智能指针或RAII技术，则程序员应该认真跟踪内存分配与释放，并在适当的时候使用delete关键字释放内存。</li></ul>',8),c=[o];function r(n,s,p,d,_,h){return t(),a("div",null,c)}const m=e(l,[["render",r]]);export{I as __pageData,m as default};

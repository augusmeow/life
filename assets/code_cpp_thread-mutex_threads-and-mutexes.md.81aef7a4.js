import{_ as s,c as a,o as n,Q as l}from"./chunks/framework.1cc28bed.js";const o="/life/img/code/stanford/process.png",e="/life/img/code/stanford/threads_share_memory.png",p="/life/img/code/stanford/locked_door.png",F=JSON.parse('{"title":"Threads and Mutexes","description":"","frontmatter":{},"headers":[],"relativePath":"code/cpp/thread-mutex/threads-and-mutexes.md","filePath":"code/cpp/thread-mutex/threads-and-mutexes.md","lastUpdated":1682241505000}'),t={name:"code/cpp/thread-mutex/threads-and-mutexes.md"},r=l('<h1 id="threads-and-mutexes" tabindex="-1">Threads and Mutexes <a class="header-anchor" href="#threads-and-mutexes" aria-label="Permalink to &quot;Threads and Mutexes&quot;">​</a></h1><p>from <a href="https://web.stanford.edu/class/archive/cs/cs110/cs110.1204/static/lectures/10-threads-and-mutexes.pdf" target="_blank" rel="noreferrer">stanford</a> edu <strong>CS110 Lecture 10: Threads and Mutexes</strong></p><p><strong>CS110 Lecture 10: Threads and Mutexes</strong></p><p>Principles of Computer Systems<br> Winter 2020 Stanford University Computer Science Department<br><strong>Instructors</strong>: Chris Gregg and Nick Troccoli</p><p><strong>CS110 Topic 3</strong>: How can we have concurrency within a single process?</p><h2 id="learning-about-processes" tabindex="-1">Learning About Processes <a class="header-anchor" href="#learning-about-processes" aria-label="Permalink to &quot;Learning About Processes&quot;">​</a></h2><p><img src="'+o+`" alt=""></p><h2 id="today-s-learning-goals" tabindex="-1">Today&#39;s Learning Goals <a class="header-anchor" href="#today-s-learning-goals" aria-label="Permalink to &quot;Today&#39;s Learning Goals&quot;">​</a></h2><ul><li>Discover some of the pitfalls of threads sharing the same virtual address space</li><li>Learn how locks can help us limit access to shared resources</li><li>Get practice using condition variables to wait for signals from other threads</li></ul><h2 id="plan-for-today" tabindex="-1">Plan For Today <a class="header-anchor" href="#plan-for-today" aria-label="Permalink to &quot;Plan For Today&quot;">​</a></h2><ul><li><strong>Recap:</strong> Threads in C++</li><li>Races When Accessing Shared Data</li><li>Introducing Mutexes</li></ul><h3 id="recap-threads-in-c" tabindex="-1"><strong>Recap:</strong> Threads in C++ <a class="header-anchor" href="#recap-threads-in-c" aria-label="Permalink to &quot;**Recap:** Threads in C++&quot;">​</a></h3><h4 id="threads" tabindex="-1">Threads <a class="header-anchor" href="#threads" aria-label="Permalink to &quot;Threads&quot;">​</a></h4><p>A <strong>thread</strong> is an independent execution sequence within a single process.</p><ul><li>Most common: assign each thread to execute a single function in parallel</li><li>Each thread operates within the same process, so they <em>share global data</em>(!) (text, data, and heap segments)</li><li>They each have their own stack (e.g. for calls within a single thread)</li><li>Execution alternates between threads as it does for processes</li><li>Many similarities between threads and processes; in fact, threads are often called <strong>lightweight processes</strong>.</li></ul><h4 id="threads-vs-processes" tabindex="-1">Threads vs. Processes <a class="header-anchor" href="#threads-vs-processes" aria-label="Permalink to &quot;Threads vs. Processes&quot;">​</a></h4><p><strong>Processes:</strong></p><ul><li>isolate virtual address spaces (good: security and stability, bad: harder to share info)</li><li>can run external programs easily (fork-exec) (good)</li><li>harder to coordinate multiple tasks within the same program (bad)</li></ul><p><strong>Threads:</strong></p><ul><li>share virtual address space (bad: security and stability, good: easier to share info)</li><li>can&#39;t run external programs easily (bad)</li><li>easier to coordinate multiple tasks within the same program (good)</li></ul><h4 id="c-thread" tabindex="-1">C++ <strong>thread</strong> <a class="header-anchor" href="#c-thread" aria-label="Permalink to &quot;C++ **thread**&quot;">​</a></h4><p>A thread object can be spawned to run the specified function with the given arguments.</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">thread</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">myThread</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">myFunc</span><span style="color:#E1E4E8;">, </span><span style="color:#B392F0;">arg1</span><span style="color:#E1E4E8;">, </span><span style="color:#B392F0;">arg2</span><span style="color:#E1E4E8;">, ...);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">thread</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">myThread</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">myFunc</span><span style="color:#24292E;">, </span><span style="color:#6F42C1;">arg1</span><span style="color:#24292E;">, </span><span style="color:#6F42C1;">arg2</span><span style="color:#24292E;">, ...);</span></span></code></pre></div><ul><li>**myFunc:**the function the thread should execute asynchronously</li><li>**args:**a list of arguments (any length, or none) to pass to the function upon execution</li><li>Once initialized with this constructor, the thread may execute at any time!</li></ul><p>To pass objects by reference to a thread, use the **ref()**function:</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">myFunc</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">x</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">int&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">y</span><span style="color:#E1E4E8;">) {...}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">thread</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">myThread</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">myFunc</span><span style="color:#E1E4E8;">, </span><span style="color:#B392F0;">ref</span><span style="color:#E1E4E8;">(arg1), </span><span style="color:#B392F0;">ref</span><span style="color:#E1E4E8;">(arg2));</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">myFunc</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int&amp;</span><span style="color:#24292E;"> </span><span style="color:#E36209;">x</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">int&amp;</span><span style="color:#24292E;"> </span><span style="color:#E36209;">y</span><span style="color:#24292E;">) {...}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1;">thread</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">myThread</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">myFunc</span><span style="color:#24292E;">, </span><span style="color:#6F42C1;">ref</span><span style="color:#24292E;">(arg1), </span><span style="color:#6F42C1;">ref</span><span style="color:#24292E;">(arg2));</span></span></code></pre></div><p>We can make an array of threads as follows:</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// declare array of empty thread handles </span></span>
<span class="line"><span style="color:#E1E4E8;">thread friends[</span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;">]; </span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// Spawn threads</span></span>
<span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">size_t</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    friends[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">thread</span><span style="color:#E1E4E8;">(myFunc, arg1, arg2); </span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// declare array of empty thread handles </span></span>
<span class="line"><span style="color:#24292E;">thread friends[</span><span style="color:#005CC5;">5</span><span style="color:#24292E;">]; </span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// Spawn threads</span></span>
<span class="line"><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">size_t</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">5</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    friends[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">thread</span><span style="color:#24292E;">(myFunc, arg1, arg2); </span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>We can also initialize an array of threads as follows (note the loop by reference):</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">thread friends[</span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;">]; </span></span>
<span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (thread</span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;"> currFriend : friends) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    currFriend </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">thread</span><span style="color:#E1E4E8;">(myFunc, arg1, arg2); </span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">thread friends[</span><span style="color:#005CC5;">5</span><span style="color:#24292E;">]; </span></span>
<span class="line"><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (thread</span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;"> currFriend : friends) {</span></span>
<span class="line"><span style="color:#24292E;">    currFriend </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">thread</span><span style="color:#24292E;">(myFunc, arg1, arg2); </span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>To wait on a thread to finish, use the <strong>.join()</strong> method:</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">thread</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">myThread</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">myFunc</span><span style="color:#E1E4E8;">, </span><span style="color:#B392F0;">arg1</span><span style="color:#E1E4E8;">, </span><span style="color:#B392F0;">arg2</span><span style="color:#E1E4E8;">); </span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">...</span><span style="color:#6A737D;"> // do some work</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// Wait for thread to finish (blocks) </span></span>
<span class="line"><span style="color:#E1E4E8;">myThread.</span><span style="color:#B392F0;">join</span><span style="color:#E1E4E8;">();</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">thread</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">myThread</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">myFunc</span><span style="color:#24292E;">, </span><span style="color:#6F42C1;">arg1</span><span style="color:#24292E;">, </span><span style="color:#6F42C1;">arg2</span><span style="color:#24292E;">); </span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">...</span><span style="color:#6A737D;"> // do some work</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// Wait for thread to finish (blocks) </span></span>
<span class="line"><span style="color:#24292E;">myThread.</span><span style="color:#6F42C1;">join</span><span style="color:#24292E;">();</span></span></code></pre></div><p>For multiple threads, we must wait on a specific thread one at a time:</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">thread friends[</span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;">]; </span></span>
<span class="line"><span style="color:#6A737D;">// spawn here</span></span>
<span class="line"><span style="color:#6A737D;">// now we wait for each to finish </span></span>
<span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">size_t</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) { </span></span>
<span class="line"><span style="color:#E1E4E8;">    friends[i].</span><span style="color:#B392F0;">join</span><span style="color:#E1E4E8;">(); </span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">thread friends[</span><span style="color:#005CC5;">5</span><span style="color:#24292E;">]; </span></span>
<span class="line"><span style="color:#6A737D;">// spawn here</span></span>
<span class="line"><span style="color:#6A737D;">// now we wait for each to finish </span></span>
<span class="line"><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">size_t</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">5</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) { </span></span>
<span class="line"><span style="color:#24292E;">    friends[i].</span><span style="color:#6F42C1;">join</span><span style="color:#24292E;">(); </span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h4 id="thread-safety" tabindex="-1">Thread Safety <a class="header-anchor" href="#thread-safety" aria-label="Permalink to &quot;Thread Safety&quot;">​</a></h4><p>A <em>thread-safe</em>function is one that will always execute correctly, even when called concurrently from multiple threads.</p><ul><li><strong>printf</strong>is thread-safe, but **operator&lt;&lt;**is <em>not</em>. This means e.g. <strong>cout</strong> statements could get interleaved!</li><li>To avoid this, use <strong>oslock</strong>and <strong>osunlock</strong>(custom CS110 functions - <strong>#include &quot;ostreamlock.h&quot;</strong>) around streams. They ensure at most one thread has permission to write into a stream at any one time.</li></ul><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">cout </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> oslock </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&quot;Hello, world!&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;">  endl </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> osunlock;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">cout </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> oslock </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;">  </span><span style="color:#032F62;">&quot;Hello, world!&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;">  endl </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> osunlock;</span></span></code></pre></div><h4 id="threads-share-memory" tabindex="-1">Threads Share Memory <a class="header-anchor" href="#threads-share-memory" aria-label="Permalink to &quot;Threads Share Memory&quot;">​</a></h4><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">greeting</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">size_t&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">i</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    cout </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> oslock </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;Hello, world! I am thread &quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> endl </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> osunlock; </span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">size_t</span><span style="color:#E1E4E8;"> kNumFriends </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">6</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">argc</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">char</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#FFAB70;">argv</span><span style="color:#E1E4E8;">[]) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    cout </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;Let&#39;s hear from &quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> kNumFriends </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot; threads.&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> endl;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    thread friends[kNumFriends];</span><span style="color:#6A737D;"> // declare array of empty thread handles</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">    // Spawn threads</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">size_t</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> kNumFriends; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        friends[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">thread</span><span style="color:#E1E4E8;">(greeting, </span><span style="color:#B392F0;">ref</span><span style="color:#E1E4E8;">(i));</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">    // Wait for threads</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">size_t</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> kNumFriends; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    friends[i].</span><span style="color:#B392F0;">join</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    cout </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;Everyone&#39;s said hello!&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> endl;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">greeting</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">size_t&amp;</span><span style="color:#24292E;"> </span><span style="color:#E36209;">i</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    cout </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> oslock </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;Hello, world! I am thread &quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> endl </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> osunlock; </span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">size_t</span><span style="color:#24292E;"> kNumFriends </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">6</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">argc</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">char</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#E36209;">argv</span><span style="color:#24292E;">[]) {</span></span>
<span class="line"><span style="color:#24292E;">    cout </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;Let&#39;s hear from &quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> kNumFriends </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot; threads.&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> endl;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    thread friends[kNumFriends];</span><span style="color:#6A737D;"> // declare array of empty thread handles</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">    // Spawn threads</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">size_t</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> kNumFriends; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        friends[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">thread</span><span style="color:#24292E;">(greeting, </span><span style="color:#6F42C1;">ref</span><span style="color:#24292E;">(i));</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">    // Wait for threads</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">size_t</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> kNumFriends; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    friends[i].</span><span style="color:#6F42C1;">join</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    cout </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;Everyone&#39;s said hello!&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> endl;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>Output</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">$</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">./friends</span></span>
<span class="line"><span style="color:#B392F0;">Let</span><span style="color:#B392F0;">&#39;s hear from 6 threads.</span></span>
<span class="line"><span style="color:#B392F0;">Hello, world! I am thread 2 </span></span>
<span class="line"><span style="color:#B392F0;">Hello, world! I am thread 2 </span></span>
<span class="line"><span style="color:#B392F0;">Hello, world! I am thread 3 </span></span>
<span class="line"><span style="color:#B392F0;">Hello, world! I am thread 5 </span></span>
<span class="line"><span style="color:#B392F0;">Hello, world! I am thread 5 </span></span>
<span class="line"><span style="color:#B392F0;">Hello, world! I am thread 6 </span></span>
<span class="line"><span style="color:#B392F0;">Everyone&#39;</span><span style="color:#B392F0;">s</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">said</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">hello!</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">$</span><span style="color:#24292E;"> </span><span style="color:#032F62;">./friends</span></span>
<span class="line"><span style="color:#6F42C1;">Let</span><span style="color:#6F42C1;">&#39;s hear from 6 threads.</span></span>
<span class="line"><span style="color:#6F42C1;">Hello, world! I am thread 2 </span></span>
<span class="line"><span style="color:#6F42C1;">Hello, world! I am thread 2 </span></span>
<span class="line"><span style="color:#6F42C1;">Hello, world! I am thread 3 </span></span>
<span class="line"><span style="color:#6F42C1;">Hello, world! I am thread 5 </span></span>
<span class="line"><span style="color:#6F42C1;">Hello, world! I am thread 5 </span></span>
<span class="line"><span style="color:#6F42C1;">Hello, world! I am thread 6 </span></span>
<span class="line"><span style="color:#6F42C1;">Everyone&#39;</span><span style="color:#6F42C1;">s</span><span style="color:#24292E;"> </span><span style="color:#032F62;">said</span><span style="color:#24292E;"> </span><span style="color:#032F62;">hello!</span></span></code></pre></div><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> ( </span><span style="color:#F97583;">size_t</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> kNumFriends; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    friends[i].</span><span style="color:#B392F0;">join</span><span style="color:#E1E4E8;">();    </span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">for</span><span style="color:#24292E;"> ( </span><span style="color:#D73A49;">size_t</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;">  </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> kNumFriends; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    friends[i].</span><span style="color:#6F42C1;">join</span><span style="color:#24292E;">();    </span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><img src="`+e+`" alt=""></p><p><strong>Solution</strong>: pass a copy of i (not by reference) so it does not change.</p><h3 id="races-when-accessing-shared-data" tabindex="-1"><strong>Races When Accessing Shared Data</strong> <a class="header-anchor" href="#races-when-accessing-shared-data" aria-label="Permalink to &quot;**Races When Accessing Shared Data**&quot;">​</a></h3><h4 id="thread-level-parallelism" tabindex="-1">Thread-Level Parallelism <a class="header-anchor" href="#thread-level-parallelism" aria-label="Permalink to &quot;Thread-Level Parallelism&quot;">​</a></h4><ul><li>Threads allow a process to parallelize a problem across multiple cores</li><li>Consider a scenario where we want to process 250 images and have 10 cores</li><li><strong>Simulation</strong>: let each thread help process images until none are left</li><li>Let&#39;s jump to a demo to see how this works</li></ul><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">argc</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">char</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#FFAB70;">argv</span><span style="color:#E1E4E8;">[]) { </span></span>
<span class="line"><span style="color:#E1E4E8;">    thread processors[</span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">]; </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">size_t</span><span style="color:#E1E4E8;"> remainingImages </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">250</span><span style="color:#E1E4E8;">; </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">size_t</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">)     </span></span>
<span class="line"><span style="color:#E1E4E8;">        processors[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">thread</span><span style="color:#E1E4E8;">(process, </span><span style="color:#79B8FF;">101</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> i, </span><span style="color:#B392F0;">ref</span><span style="color:#E1E4E8;">(remainingImages));   </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (thread</span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;"> proc: processors) proc.</span><span style="color:#B392F0;">join</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    cout </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;Images done!&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> endl; </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; </span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">argc</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">char</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#E36209;">argv</span><span style="color:#24292E;">[]) { </span></span>
<span class="line"><span style="color:#24292E;">    thread processors[</span><span style="color:#005CC5;">10</span><span style="color:#24292E;">]; </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">size_t</span><span style="color:#24292E;"> remainingImages </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">250</span><span style="color:#24292E;">; </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">size_t</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">10</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">)     </span></span>
<span class="line"><span style="color:#24292E;">        processors[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">thread</span><span style="color:#24292E;">(process, </span><span style="color:#005CC5;">101</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> i, </span><span style="color:#6F42C1;">ref</span><span style="color:#24292E;">(remainingImages));   </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (thread</span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;"> proc: processors) proc.</span><span style="color:#6F42C1;">join</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    cout </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;Images done!&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> endl; </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; </span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>There is a <em>race condition</em> here!</p><ul><li><p>**Problem:**threads could interrupt each other in between lines 2 and 3.</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">static</span><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">process</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">size_t</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">id</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">size_t&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">remainingImages</span><span style="color:#E1E4E8;">) { </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (remainingImages </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {  </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">sleep_for</span><span style="color:#E1E4E8;">( </span><span style="color:#79B8FF;">500</span><span style="color:#E1E4E8;"> );</span><span style="color:#6A737D;">   // simulate &quot;processing image&quot; </span></span>
<span class="line"><span style="color:#E1E4E8;">        remainingImages</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#6A737D;">        // ...    </span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#6A737D;">    //... </span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">static</span><span style="color:#24292E;">  </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">process</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">size_t</span><span style="color:#24292E;"> </span><span style="color:#E36209;">id</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">size_t&amp;</span><span style="color:#24292E;"> </span><span style="color:#E36209;">remainingImages</span><span style="color:#24292E;">) { </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (remainingImages </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;">  </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {  </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">sleep_for</span><span style="color:#24292E;">( </span><span style="color:#005CC5;">500</span><span style="color:#24292E;"> );</span><span style="color:#6A737D;">   // simulate &quot;processing image&quot; </span></span>
<span class="line"><span style="color:#24292E;">        remainingImages</span><span style="color:#D73A49;">--</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#6A737D;">        // ...    </span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#6A737D;">    //... </span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div></li><li><p>**Why is this?**It&#39;s because <strong>remainingImages &gt; 0</strong> test and <strong>remainingImages--</strong> aren&#39;t atomic</p></li><li><p>Atomicity: externally, the code has either executed or not; external observers do not see any intermediate states mid-execution</p></li><li><p>If a thread evaluates <strong>remainingImages &gt; 0</strong>to be <strong>true</strong>and commits to processing an image, another thread could come in and claim that same image before this thread processes it.</p></li></ul><h4 id="why-test-and-decrement-is-really-not-thread-safe" tabindex="-1">Why Test and Decrement Is REALLY NOT Thread-Safe <a class="header-anchor" href="#why-test-and-decrement-is-really-not-thread-safe" aria-label="Permalink to &quot;Why Test and Decrement Is REALLY NOT Thread-Safe&quot;">​</a></h4><ul><li><p>C++ statements aren&#39;t inherently atomic. Virtually all C++ statements—even ones as simple as <strong>remainingImages--</strong>—compile to multiple assembly code instructions.</p></li><li><p>Assembly code instructions are atomic, but C++ statements are not.</p></li><li><p><strong>g++</strong> on the myths compiles <strong>remainingImages--</strong> to five assembly code instructions, as with:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">0x0000000000401a9b &lt;+36&gt;:   mov    -0x20(%rbp),%rax</span></span>
<span class="line"><span style="color:#e1e4e8;">0x0000000000401a9f &lt;+40&gt;:   mov    (%rax),%eax</span></span>
<span class="line"><span style="color:#e1e4e8;">0x0000000000401aa1 &lt;+42&gt;:   lea    -0x1(%rax),%edx</span></span>
<span class="line"><span style="color:#e1e4e8;">0x0000000000401aa4 &lt;+45&gt;:   mov    -0x20(%rbp),%rax</span></span>
<span class="line"><span style="color:#e1e4e8;">0x0000000000401aa8 &lt;+49&gt;:   mov    %edx,(%rax)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">0x0000000000401a9b &lt;+36&gt;:   mov    -0x20(%rbp),%rax</span></span>
<span class="line"><span style="color:#24292e;">0x0000000000401a9f &lt;+40&gt;:   mov    (%rax),%eax</span></span>
<span class="line"><span style="color:#24292e;">0x0000000000401aa1 &lt;+42&gt;:   lea    -0x1(%rax),%edx</span></span>
<span class="line"><span style="color:#24292e;">0x0000000000401aa4 &lt;+45&gt;:   mov    -0x20(%rbp),%rax</span></span>
<span class="line"><span style="color:#24292e;">0x0000000000401aa8 &lt;+49&gt;:   mov    %edx,(%rax)</span></span></code></pre></div></li><li><p>The first two lines drill through the <strong>remainingImages</strong> reference to load a copy of the <strong>remainingImages</strong> held on <strong>main</strong>&#39;s stack. The third line decrements that copy, and the last two write the decremented copy back to the <strong>remainingImages</strong> variable held on <strong>main</strong>&#39;s stack.</p></li><li><p>The ALU operates on registers, but registers are private to a core, so the variable needs to be loaded from and stored to memory.</p><ul><li>Each thread makes a local copy of the variable before operating on it</li><li>What if multiple threads all load the variable at the same time: they all think there&#39;s only 128 images remaining and process 128 at the same time</li></ul></li></ul><h3 id="introducing-mutexes" tabindex="-1">Introducing Mutexes <a class="header-anchor" href="#introducing-mutexes" aria-label="Permalink to &quot;Introducing Mutexes&quot;">​</a></h3><h4 id="mutex" tabindex="-1">Mutex <a class="header-anchor" href="#mutex" aria-label="Permalink to &quot;Mutex&quot;">​</a></h4><p>A mutex is a variable type that represents something like a &quot;locked door&quot;.</p><p><img src="`+p+`" alt=""></p><p>You can <strong>lock</strong>the door:</p><ul><li>if it&#39;s unlocked, you go through the door and lock it</li><li>if it&#39;s locked, you <em>wait for it to unlock first</em></li></ul><p>If you most recently locked the door, you can <strong>unlock</strong>the door:</p><ul><li>door is now unlocked, another may go in now</li></ul><h4 id="mutex-mutual-exclusion" tabindex="-1">Mutex - Mutual Exclusion <a class="header-anchor" href="#mutex-mutual-exclusion" aria-label="Permalink to &quot;Mutex - Mutual Exclusion&quot;">​</a></h4><p>A mutex is a type used to enforce <em>mutual exclusion</em>, i.e., a critical section</p><p>Mutexes are often called locks</p><ul><li>To be very precise, mutexes are one kind of lock, there are others (read/write locks, reentrant locks, etc.), but we can just call them locks in this course, usually &quot;lock&quot; means &quot;mutex&quot;</li></ul><p>When a thread locks a mutex</p><ul><li>If the lock is unlocked the thread takes the lock and continues execution</li><li>If the lock is locked, the thread blocks and waits until the lock is unlocked</li><li>If multiple threads are waiting for a lock they all wait until lock is unlocked, one receives lock</li></ul><p>When a thread unlocks a mutex</p><ul><li>It continues normally; one waiting thread (if any) takes the lock and is scheduled to run</li></ul><p>This is a subset of the C++ mutex abstraction: nicely simple! How can we use this in our buggy program?</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">mutex</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">public:</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">mutex</span><span style="color:#E1E4E8;">();</span><span style="color:#6A737D;">        // constructs the mutex to be in an unlocked state</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">();</span><span style="color:#6A737D;">    // acquires the lock on the mutex, blocking until it&#39;s unlocked</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">unlock</span><span style="color:#E1E4E8;">();</span><span style="color:#6A737D;">  // releases the lock and wakes up another threads trying to lock it</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">mutex</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#D73A49;">public:</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">mutex</span><span style="color:#24292E;">();</span><span style="color:#6A737D;">        // constructs the mutex to be in an unlocked state</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">();</span><span style="color:#6A737D;">    // acquires the lock on the mutex, blocking until it&#39;s unlocked</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">();</span><span style="color:#6A737D;">  // releases the lock and wakes up another threads trying to lock it</span></span>
<span class="line"><span style="color:#24292E;">};</span></span></code></pre></div><h4 id="critical-sections-with-mutexes" tabindex="-1">Critical Sections With Mutexes <a class="header-anchor" href="#critical-sections-with-mutexes" aria-label="Permalink to &quot;Critical Sections With Mutexes&quot;">​</a></h4><p><strong>main</strong> instantiates a mutex, which it passes (by reference!) to invocations of <strong>process.</strong> The <strong>process</strong> code uses this lock to protect <strong>remainingImages</strong>. Note we need to unlock on line 5 -- in complex code forgetting this is an easy bug</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">process</span><span style="color:#E1E4E8;"> ( </span><span style="color:#F97583;">size_t</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">id</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">size_t</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">remainingImages</span><span style="color:#E1E4E8;">, </span><span style="color:#B392F0;">mutex</span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">counterLock</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> ( </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;"> ) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        counterLock.</span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (remainingImages </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            counterLock.</span><span style="color:#B392F0;">unlock</span><span style="color:#E1E4E8;">(); </span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">processImage</span><span style="color:#E1E4E8;">(remainingImages);</span></span>
<span class="line"><span style="color:#E1E4E8;">        remainingImages</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        cout </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> oslock </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;Thread#&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> id </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot; processed an image (&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> remainingImages </span><span style="color:#79B8FF;">11</span><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot; remain).&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> endl </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> osunlock;</span></span>
<span class="line"><span style="color:#E1E4E8;">        counterLock.</span><span style="color:#B392F0;">unlock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    cout </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> oslock </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;Thread#&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> id </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot; sees no remaining images and exits.&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> endl </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> osunlock;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// Create single mutex in main, pass by reference</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">process</span><span style="color:#24292E;"> ( </span><span style="color:#D73A49;">size_t</span><span style="color:#24292E;"> </span><span style="color:#E36209;">id</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">size_t</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;"> </span><span style="color:#E36209;">remainingImages</span><span style="color:#24292E;">, </span><span style="color:#6F42C1;">mutex</span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;"> </span><span style="color:#E36209;">counterLock</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> ( </span><span style="color:#005CC5;">true</span><span style="color:#24292E;"> ) {</span></span>
<span class="line"><span style="color:#24292E;">        counterLock.</span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (remainingImages </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            counterLock.</span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">(); </span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">processImage</span><span style="color:#24292E;">(remainingImages);</span></span>
<span class="line"><span style="color:#24292E;">        remainingImages</span><span style="color:#D73A49;">--</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        cout </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> oslock </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;Thread#&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> id </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot; processed an image (&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> remainingImages </span><span style="color:#005CC5;">11</span><span style="color:#24292E;">   </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot; remain).&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> endl </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> osunlock;</span></span>
<span class="line"><span style="color:#24292E;">        counterLock.</span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    cout </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> oslock </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;Thread#&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> id </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot; sees no remaining images and exits.&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> endl </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> osunlock;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// Create single mutex in main, pass by reference</span></span></code></pre></div><h4 id="critical-sections-can-be-bottlenecks" tabindex="-1">Critical Sections Can Be Bottlenecks <a class="header-anchor" href="#critical-sections-can-be-bottlenecks" aria-label="Permalink to &quot;Critical Sections Can Be Bottlenecks&quot;">​</a></h4><p>The way we&#39;ve set it up, only one thread agent can process an image at a time!</p><p>We can do better: serialize deciding which image to process and parallelize the actual processing</p><p>Keep your critical sections as small as possible!</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">process</span><span style="color:#E1E4E8;"> ( </span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">_t</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">id</span><span style="color:#E1E4E8;">, </span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">_t</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">remainingImages</span><span style="color:#E1E4E8;">, </span><span style="color:#B392F0;">mutex</span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">counterLock</span><span style="color:#E1E4E8;">) { </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> ( </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;"> ) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        size _t myImage; </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span></span>
<span class="line"><span style="color:#E1E4E8;">        counterLock.</span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">();</span><span style="color:#6A737D;">   // Start of critical section </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (remainingImages </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) { </span></span>
<span class="line"><span style="color:#E1E4E8;">            counterLock.</span><span style="color:#B392F0;">unlock</span><span style="color:#E1E4E8;">();</span><span style="color:#6A737D;"> // Rather keep it here, easier to check </span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> { </span></span>
<span class="line"><span style="color:#E1E4E8;">            myImage </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> remainingImages; </span></span>
<span class="line"><span style="color:#E1E4E8;">            remainingImages</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">; </span></span>
<span class="line"><span style="color:#E1E4E8;">            counterLock.</span><span style="color:#B392F0;">unlock</span><span style="color:#E1E4E8;">();</span><span style="color:#6A737D;"> // end of critical section </span></span>
<span class="line"><span style="color:#E1E4E8;">            </span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">processImage</span><span style="color:#E1E4E8;">(myImage); </span></span>
<span class="line"><span style="color:#E1E4E8;">            cout </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> oslock </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;Thread#&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> id </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot; processed an image (&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> remainingImages </span><span style="color:#79B8FF;">16</span><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot; remain).&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> endl </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> osunlock; </span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span></span>
<span class="line"><span style="color:#E1E4E8;">    cout </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> oslock </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;Thread#&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> id </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot; sees no remaining images and exits.&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> endl </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> osunlock; </span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">process</span><span style="color:#24292E;"> ( </span><span style="color:#6F42C1;">size</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">_t</span><span style="color:#24292E;"> </span><span style="color:#E36209;">id</span><span style="color:#24292E;">, </span><span style="color:#6F42C1;">size</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">_t</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;"> </span><span style="color:#E36209;">remainingImages</span><span style="color:#24292E;">, </span><span style="color:#6F42C1;">mutex</span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;"> </span><span style="color:#E36209;">counterLock</span><span style="color:#24292E;">) { </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> ( </span><span style="color:#005CC5;">true</span><span style="color:#24292E;"> ) {</span></span>
<span class="line"><span style="color:#24292E;">        size _t myImage; </span></span>
<span class="line"><span style="color:#24292E;">        </span></span>
<span class="line"><span style="color:#24292E;">        counterLock.</span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">();</span><span style="color:#6A737D;">   // Start of critical section </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (remainingImages </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) { </span></span>
<span class="line"><span style="color:#24292E;">            counterLock.</span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">();</span><span style="color:#6A737D;"> // Rather keep it here, easier to check </span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> { </span></span>
<span class="line"><span style="color:#24292E;">            myImage </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> remainingImages; </span></span>
<span class="line"><span style="color:#24292E;">            remainingImages</span><span style="color:#D73A49;">--</span><span style="color:#24292E;">; </span></span>
<span class="line"><span style="color:#24292E;">            counterLock.</span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">();</span><span style="color:#6A737D;"> // end of critical section </span></span>
<span class="line"><span style="color:#24292E;">            </span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">processImage</span><span style="color:#24292E;">(myImage); </span></span>
<span class="line"><span style="color:#24292E;">            cout </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> oslock </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;Thread#&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> id </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot; processed an image (&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> remainingImages </span><span style="color:#005CC5;">16</span><span style="color:#24292E;">   </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot; remain).&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> endl </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> osunlock; </span></span>
<span class="line"><span style="color:#24292E;">        } </span></span>
<span class="line"><span style="color:#24292E;">    } </span></span>
<span class="line"><span style="color:#24292E;">    cout </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> oslock </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;Thread#&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> id </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot; sees no remaining images and exits.&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> endl </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> osunlock; </span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h4 id="problems-that-might-arise" tabindex="-1">Problems That Might Arise <a class="header-anchor" href="#problems-that-might-arise" aria-label="Permalink to &quot;Problems That Might Arise&quot;">​</a></h4><p>What if <strong>processImage</strong> can return an error?</p><ul><li>E.g., what if we need to distinguish allocating an image and processing it</li><li>A thread can grab the image by decrementing <strong>remainingImages</strong> but if it fails there&#39;s no way for another thread to retry</li><li>Because these are threads, if one thread has a SEGV the whole process will fail</li><li>A more complex approach might be to maintain an actual queue of images and allow threads (in a critical section) to push things back into the queue</li></ul><p>What if image processing times are <em>highly</em> variable (e.g, one image takes 100x as long as the others)?</p><ul><li>Might scan images to estimate execution time and try more intelligent scheduling</li></ul><p>What if there&#39;s a bug in your code, such that sometimes processImage randomly enters an infinite loop?</p><ul><li>Need a way to reissue an image to an idle thread</li><li>An infinite loop of course shouldn&#39;t occur, but when we get to networks sometimes execution time can vary by 100x for reasons outside our control</li></ul><h4 id="some-types-of-mutexes" tabindex="-1">Some Types of Mutexes <a class="header-anchor" href="#some-types-of-mutexes" aria-label="Permalink to &quot;Some Types of Mutexes&quot;">​</a></h4><p>Standard <strong>mutex</strong>: what we&#39;ve seen</p><ul><li>If a thread holding the lock tries to re-lock it, deadlock</li></ul><p><strong>recursive_mutex</strong></p><ul><li>A thread can lock the mutex multiple times, and needs to unlock it the same number of times to release it to other threads</li></ul><p><strong>timed_mutex</strong></p><ul><li>A thread can <strong>try_lock_for</strong> / <strong>try_lock_until</strong>: if time elapses, don&#39;t take lock</li><li>Deadlocks if same thread tries to lock multiple times, like standard mutex</li></ul><p>In this class, we&#39;ll focus on just regular <strong>mutex</strong></p><h4 id="how-do-mutexes-work" tabindex="-1">How Do Mutexes Work? <a class="header-anchor" href="#how-do-mutexes-work" aria-label="Permalink to &quot;How Do Mutexes Work?&quot;">​</a></h4><p>Something we&#39;ve seen a few times is that you can&#39;t read and write a variable atomically</p><ul><li>But a mutex does so! If the lock is unlocked, lock it</li></ul><p>How does this work with caches?</p><ul><li>Each core has its own cache</li><li>Writes are typically write-back (write to higher cache level when line is evicted), not write-through (always write to main memory) for performance</li><li>Caches are <em>coherent</em> -- if one core writes to a cache line that is also in another core&#39;s cache, the other core&#39;s cache line is invalidated: this can become a performance problem</li></ul><p>Hardware provides atomic memory operations, such as compare and swap</p><ul><li>cas old, new, addr <ul><li>If addr == old, set addr to new</li></ul></li><li>Use this as a single bit to see if the lock is held and if not, take it</li><li>If the lock is held already, then enqueue yourself (in a thread safe way) and tell kernel to sleep you</li><li>When a node unlocks, it clears the bit and wakes up a thread</li></ul>`,101),c=[r];function i(y,E,d,h,u,m){return n(),a("div",null,c)}const k=s(t,[["render",i]]);export{F as __pageData,k as default};

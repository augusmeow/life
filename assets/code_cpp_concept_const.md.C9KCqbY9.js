import{_ as s,c as a,a3 as c,o as i}from"./chunks/framework.DDs3IadZ.js";const k=JSON.parse('{"title":"const","description":"","frontmatter":{},"headers":[],"relativePath":"code/cpp/concept/const.md","filePath":"code/cpp/concept/const.md","lastUpdated":1697180748000}'),o={name:"code/cpp/concept/const.md"};function e(n,t,l,d,p,h){return i(),a("div",null,t[0]||(t[0]=[c('<h1 id="const" tabindex="-1">const <a class="header-anchor" href="#const" aria-label="Permalink to &quot;const&quot;">​</a></h1><h2 id="如何在const成员函数中赋值" tabindex="-1">如何在const成员函数中赋值？ <a class="header-anchor" href="#如何在const成员函数中赋值" aria-label="Permalink to &quot;如何在const成员函数中赋值？&quot;">​</a></h2><blockquote><p>使用<code>mutable</code>去掉const的成员函数的const性质</p></blockquote><p>为什么要有这种去除常量标志的需求？</p><ul><li>两个概念：物理常量性和逻辑常量性 <ul><li>物理常量性：实际上就是常量。</li><li>逻辑常量性：对用户而言是常量，但在用户不能访问的细节上不是常量。</li></ul></li></ul><h2 id="const-cast和mutable的比较" tabindex="-1">const_cast和mutable的比较 <a class="header-anchor" href="#const-cast和mutable的比较" aria-label="Permalink to &quot;const_cast和mutable的比较&quot;">​</a></h2><ul><li>const_cast: <ul><li>强制去掉对象的const属性。</li><li>缺点：对const对象，调用包含const_cast的const成员函数，属于未定义行为。</li></ul></li><li>mutable: <ul><li>使用场景：对可能要发生变化的成员前，加上存储描述符mutable。</li><li>实质：对加了mutable的成员，无视所有const声明。</li></ul></li></ul><h2 id="const-与-define-的比较-const有什么优点" tabindex="-1">const 与 #define 的比较，const有什么优点? <a class="header-anchor" href="#const-与-define-的比较-const有什么优点" aria-label="Permalink to &quot;const 与 #define 的比较，const有什么优点?&quot;">​</a></h2><ul><li>const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应） 。</li><li>有些集成化的调试工具可以对 const 常量进行调试，但是不能对宏常量进行调试。</li></ul><h2 id="const、static-关键字有什么区别" tabindex="-1">const、static 关键字有什么区别 <a class="header-anchor" href="#const、static-关键字有什么区别" aria-label="Permalink to &quot;const、static 关键字有什么区别&quot;">​</a></h2><p><code>const</code>和<code>static</code>都是用于声明变量时的修饰符，它们都能被用来修饰一个变量的作用域、生命周期和内存分配方式。但是，它们之间还是有一些区别的：</p><ul><li><p><code>const</code>用于声明一个变量时，它表示这个变量的值不能被修改。也就是说，如果一个变量被声明为<code>const</code>，它的值在程序执行过程中是固定的，不能被修改。</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 声明一个名为x，值为5的常量</span></span></code></pre></div></li><li><p><code>static</code>用于声明一个变量时，它表示这个变量的作用域为整个程序，而不是局限于特定的函数或块。如果一个变量被声明为<code>static</code>，它在程序开始执行时会分配内存，并在程序结束时释放内存。此外，如果一个<code>static</code>变量在多个函数中被访问，那么它的值只会被初始化一次。</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 声明一个名为x，值为5的静态变量</span></span></code></pre></div></li></ul><p>综上，<code>const</code>和<code>static</code>都是用来声明变量的修饰符，但它们之间的区别在于：<code>const</code>用来保证变量值不能被修改，而<code>static</code>用来保证变量的作用域和生命周期。</p><h2 id="如何初始化const和static数据成员" tabindex="-1">如何初始化const和static数据成员？ <a class="header-anchor" href="#如何初始化const和static数据成员" aria-label="Permalink to &quot;如何初始化const和static数据成员？&quot;">​</a></h2><p>通常在类外初始化static数据成员，但是 static const 的整型(ool，char，int，long)可以再类声明中初始化， static const的其他类型也必须在类外初始化(包括整型的数组)。</p><h2 id="static-const-和-const-static-有什么区别" tabindex="-1">static const 和 const static 有什么区别 <a class="header-anchor" href="#static-const-和-const-static-有什么区别" aria-label="Permalink to &quot;static const 和 const static 有什么区别&quot;">​</a></h2><p><code>static const</code>和<code>const static</code>在C++中没有区别。这两种表达方式都表明了一个变量是静态的（只初始化一次）且是常量（只读的，不能被修改）。</p><p>在C++中，修饰符（例如<code>static</code>和<code>const</code>）的顺序不影响其含义。因此，无论你是用<code>static const</code>还是<code>const static</code>，都表示相同的意思。</p><p>但是，通常<code>const</code>会被放在类型前面，例如<code>const int</code>，因此<code>static const</code>更常见。这也是推荐的书写方法，因为它与<code>const</code>本身被放在类型前面的一般惯用法相一致。</p>',19)]))}const u=s(o,[["render",e]]);export{k as __pageData,u as default};

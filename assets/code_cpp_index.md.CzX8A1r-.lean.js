import{_ as s,c as a,a3 as t,o as n}from"./chunks/framework.DDs3IadZ.js";const c=JSON.parse('{"title":"特性","description":"","frontmatter":{},"headers":[],"relativePath":"code/cpp/index.md","filePath":"code/cpp/index.md","lastUpdated":1716791141000}'),l={name:"code/cpp/index.md"};function e(p,i,h,k,r,d){return n(),a("div",null,i[0]||(i[0]=[t(`<h1 id="特性" tabindex="-1">特性 <a class="header-anchor" href="#特性" aria-label="Permalink to &quot;特性&quot;">​</a></h1><h2 id="c-23-有什么新特性" tabindex="-1">C++23 有什么新特性 <a class="header-anchor" href="#c-23-有什么新特性" aria-label="Permalink to &quot;C++23 有什么新特性&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">Link <a href="https://en.cppreference.com/w/cpp/23" target="_blank" rel="noreferrer">cppreference</a></p><p>...etc</p></div><h2 id="c-20-有什么新特性" tabindex="-1">C++20 有什么新特性 <a class="header-anchor" href="#c-20-有什么新特性" aria-label="Permalink to &quot;C++20 有什么新特性&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">Link <a href="https://en.cppreference.com/w/cpp/20" target="_blank" rel="noreferrer">cppreference</a></p><ul><li>Feature test macros</li><li>Three-way comparison operator <code>&lt;=&gt;</code> and operator==() = default</li><li>Designated initializers</li><li>Init-statements and initializers in range-for</li><li>char8_t</li><li>New attributes: [[no_unique_address]], [[likely]], [[unlikely]]</li><li>Pack-expansions in lambda init-captures</li><li>Removed the requirement to use typename to disambiguate types in many contexts</li><li>consteval, constinit</li><li>Further relaxed constexpr</li><li>Signed integers are 2&#39;s complement</li><li>Bitwise shift operators unified behavior</li><li>aggregate initialization using parentheses</li><li>coroutines</li><li>modules</li><li>Constraints and concepts</li><li>Abbreviated function template</li><li>DR11: array new can deduce array size</li></ul></div><h2 id="c-17-有什么新特性" tabindex="-1">C++17 有什么新特性 <a class="header-anchor" href="#c-17-有什么新特性" aria-label="Permalink to &quot;C++17 有什么新特性&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">Link <a href="https://en.cppreference.com/w/cpp/17" target="_blank" rel="noreferrer">cppreference</a></p><p>...etc</p></div><h2 id="c-14-有什么新特性" tabindex="-1">C++14 有什么新特性 <a class="header-anchor" href="#c-14-有什么新特性" aria-label="Permalink to &quot;C++14 有什么新特性&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">Link <a href="https://en.cppreference.com/w/cpp/14" target="_blank" rel="noreferrer">cppreference</a></p><ul><li>variable templates</li><li>generic lambdas</li><li>lambda init-capture</li><li>new/delete elision</li><li>relaxed restrictions on constexpr functions</li><li>binary literals</li><li>digit separators</li><li>return type deduction for functions</li><li>aggregate classes with default non-static member initializers.</li></ul></div><h2 id="c-11-有什么新特性" tabindex="-1">C++11 有什么新特性 <a class="header-anchor" href="#c-11-有什么新特性" aria-label="Permalink to &quot;C++11 有什么新特性&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">Link <a href="https://en.cppreference.com/w/cpp/11" target="_blank" rel="noreferrer">cppreference</a></p><ul><li>auto and decltype</li><li>defaulted and deleted functions</li><li>final and override</li><li>trailing return type</li><li>rvalue references</li><li>move constructors and move assignment operators</li><li>scoped enums</li><li>constexpr and literal types</li><li>list initialization</li><li>delegating and inherited constructors</li><li>brace-or-equal initializers</li><li>nullptr</li><li>long long</li><li>char16_t and char32_t</li><li>type aliases</li><li>variadic templates</li><li>generalized (non-trivial) unions</li><li>generalized PODs (trivial types and standard-layout types)</li><li>Unicode string literals</li><li>user-defined literals</li><li>attributes</li><li>lambda expressions</li><li>noexcept specifier and noexcept operator</li><li>alignof and alignas</li><li>multithreaded memory model</li><li>thread-local storage</li><li>GC interface (removed in C++23)</li><li>range-for (based on a Boost library)</li><li>static_assert (based on a Boost library)</li></ul></div><h3 id="线程库" tabindex="-1">线程库 <a class="header-anchor" href="#线程库" aria-label="Permalink to &quot;线程库&quot;">​</a></h3><p>C++11中提供了一个多线程库，它可以让程序员在C++代码中创建和管理多线程。这个库包含了许多类和函数，可以用来操作线程、互斥量、条件变量和其他的同步对象。</p><p>下面是一个简单的C++11多线程程序的例子，它创建了两个线程，分别打印&quot;hello&quot;和&quot;world&quot;：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;iostream&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;thread&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::thread </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">t1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([]() { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::cout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;hello&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::endl; });</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::thread </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">t2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([]() { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::cout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;world&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::endl; });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  t1.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">join</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  t2.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">join</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在这个程序中，我们使用了<code>std::thread</code>类来创建新的线程，并使用<code>join()</code>函数来等待线程结束。由于C++11的多线程库包含了许多类和函数，所以可以支持多种多线程编程模型，比如生产者-消费者模型、同步-异步模型等等。</p><p>在C++11中，如果想要使用多线程库，需要在代码中包含<code>&lt;thread&gt;</code>头文件。这个头文件包含了所有多线程库的声明，并且提供了一些宏定义和常量，可以用来查询系统的多线程支持情况。</p><p>例如，可以使用<code>std::thread::hardware_concurrency()</code>函数来获取系统的最大线程数，或者使用<code>std::this_thread::get_id()</code>函数来获取当前线程的标识符，等等。</p><p>除了<code>&lt;thread&gt;</code>头文件之外，C++11的多线程库还包含了其他几个头文件，它们可以用来实现更为复杂的多线程程序。例如，<code>&lt;mutex&gt;</code>头文件包含了互斥量类型和函数，可以用来保证多个线程对共享数据的互斥访问；<code>&lt;future&gt;</code>头文件包含了<code>future</code>和<code>promise</code>类型，可以用来实现线程间的同步和通信等等。</p><p>总之，C++11的多线程库为C++程序员提供了一系列的工具和类型，可以让他们编写高性能的多线程程序。</p><h3 id="智能指针" tabindex="-1">智能指针 <a class="header-anchor" href="#智能指针" aria-label="Permalink to &quot;智能指针&quot;">​</a></h3><p>智能指针是一种智能指针类型，它在管理内存时具有智能化的行为。普通的指针只能表示一个内存地址，而智能指针则具有自动释放内存和避免野指针等特性。</p><p>在C++11中，智能指针主要由两个模板类实现：<code>std::unique_ptr</code>和<code>std::shared_ptr</code>。</p><p><code>std::unique_ptr</code>表示一个独占的指针，它管理的内存在任何时候都只能被一个指针所指向。例如，当一个<code>std::unique_ptr</code>对象被析构时，它所管理的内存会被自动释放。 <code>std::shared_ptr</code>表示一个共享的指针，它管理的内存可以被多个指针所指向。例如，当一个<code>std::shared_ptr</code>对象的引用计数变为0时，它所管理的内存会被自动释放。 下面是一个使用<code>std::unique_ptr</code>的简单示例：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;iostream&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;memory&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::unique_ptr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;int&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 声明一个独占指针，并分配一个int类型的对象</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::cout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::endl;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 输出指针指向的对象的值</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在这个程序中，我们声明了一个<code>std::unique_ptr</code>类型的指针p，并使用它来指向一个int类型的内存。我们可以通过解引用指针的方式来访问指针指向的对象，就像使用普通指针一样。当程序执行完毕，智能指针p会被析构，它所管理的内存就会被自动释放，避免了内存泄漏。</p><p>另一个模板类<code>std::shared_ptr</code>的用法也非常相似，下面是一个使用<code>std::shared_ptr</code>的简单示例：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;iostream&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;memory&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::shared_ptr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;int&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> p1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 声明一个共享指针，并分配一个int类型的对象</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::cout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::endl;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 输出指针指向的对象的值</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::shared_ptr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;int&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p1;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 将一个共享指针赋值给另一个共享指针</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::cout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p1.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">use_count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot; &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p2.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">use_count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::endl;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 输出两个指针的引用计数</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在这个程序中，我们声明了两个<code>std::shared_ptr</code>类型的指针p1和p2，并让它们指向同一个int类型的对象。我们可以通过调用指针的<code>use_count()</code>方法来获取它的引用计数，表示当前有多少个指针指向这个内存。当程序执行完毕，如果所有的指针都被析构了，智能指针所管理的内存就会被自动释放，避免了内存泄漏。</p><p>总之，智能指针是C++11中一个非常实用的类型，它可以自动管理内存的生命周期，减少程序员手动管理内存的工作量，并且可以避免常见的内存错误。</p><h3 id="auto" tabindex="-1">auto <a class="header-anchor" href="#auto" aria-label="Permalink to &quot;auto&quot;">​</a></h3><blockquote><p>自动类型推导</p></blockquote><p>当与<code>const</code>结合使用时</p><ul><li>当类型不为引用时，auto 的推导结果将不保留表达式的 const 属性；</li><li>当类型为引用时，auto 的推导结果将保留表达式的 const 属性。</li></ul><p>auto的限制</p><ul><li><p>使用 auto 的时候必须对变量进行初始化</p></li><li><p>auto 不能在函数的参数中使用</p><ul><li>这个很容易理解，我们在定义函数的时候只是对参数进行了声明，指明了参数的类型，但并没有给它赋值，只有在实际调用函数的时候才会给参数赋值；而 auto 要求必须对变量进行初始化，所以这是矛盾的。</li></ul></li><li><p>auto 不能作用于类的非静态成员变量（也就是没有 static 关键字修饰的成员变量）中</p><ul><li>可以用<code>decltype</code>定义，如下就可以写成<code>decltype(T().begin()) m_it;</code></li></ul><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typename</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    typename</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">iterator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> m_it;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>auto 关键字不能定义数组</p></li><li><p>auto 不能作用于模板参数</p></li></ul><p>auto常用</p><ul><li>使用 auto 定义迭代器</li><li>auto 用于泛型编程</li></ul><h3 id="using" tabindex="-1">using <a class="header-anchor" href="#using" aria-label="Permalink to &quot;using&quot;">​</a></h3><p>使用<code>using</code>定义别名（替代<code>typedef</code>）</p><h3 id="支持函数模板的默认模板参数" tabindex="-1">支持函数模板的默认模板参数 <a class="header-anchor" href="#支持函数模板的默认模板参数" aria-label="Permalink to &quot;支持函数模板的默认模板参数&quot;">​</a></h3><p>函数模板是C++中一种常见的技术，它允许定义一个函数，接受任意类型的参数。例如，下面是一个简单的函数模板示例：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;iostream&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typename</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::cout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::endl;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello world&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在这个程序中，我们定义了一个名为print的函数模板，它接受一个模板参数T，表示函数接受任意类型的参数。在函数体内，我们可以像使用普通类型一样使用这个模板参数T。</p><p>C++11标准引入了一种新的语法，允许为函数模板定义默认模板参数。例如，下面是一个使用默认模板参数的函数模板示例：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;iostream&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typename</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> int&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::cout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::endl;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello world&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在这个程序中，我们为函数模板print定义了一个默认模板参数T = int，表示如果调用函数时没有指定模板参数，就会使用默认的int类型作为模板参数。因此，在上面的程序中，调用函数print时，第一次调用会自动使用默认的模板参数int，并将实际参数5赋值给函数的形式参数value。</p><p>默认模板参数的作用是简化函数模板的调用，减少程序员的工作量。例如，我们可以通过使用默认模板参数，定义一个通用的排序函数，支持任意类型的数组排序，并且不需要显式地指定模板参数：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;algorithm&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typename</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sort</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sort</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(array, array </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array[] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  sort</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(array, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在这个程序中，我们定义了一个名为sort的函数模板，它接受一个类型为T的数组和数组的长度作为参数。在函数体内，我们使用了C++标准库中的std::sort函数，将数组进行排序。因为我们没有为函数模板指定模板参数，所以编译器会自动推断出模板参数的类型，并使用默认的模板参数int进行编译。</p><p>总之，支持函数模板的默认模板参数是C++11标准的一项重要特性，它可以简化函数模板的定义和调用，提高程序的可读性和可维护性。</p><h2 id="by-stroustrup" tabindex="-1">by stroustrup <a class="header-anchor" href="#by-stroustrup" aria-label="Permalink to &quot;by stroustrup&quot;">​</a></h2><details class="details custom-block"><summary>C++11 features</summary><blockquote><p>C++11 feels like a new language -- stroustrup</p></blockquote><blockquote><p><a href="https://www.stroustrup.com/hopl20main-p5-p-bfc9cd4--final.pdf" target="_blank" rel="noreferrer">page29</a></p></blockquote><p>C++11 introduced a bewildering number of language features, including:</p><ul><li>memory model - an efficient low level-model of modern hardware as a foundation for concurrency</li><li>auto and decltype - avoiding redundant repetition of type names</li><li>range-for - simple linear traversal of ranges</li><li>move semantics and rvalue references - minimizing copying of data</li><li>uniform initialization - an (almost) completely general syntax and semantics for initializing objects of all kinds and types</li><li>nullptr - a name for the null pointer</li><li>constexpr functions - compile-time evaluated functions</li><li>user-defined literals - literals for user-defined types</li><li>raw string literals - literals where escape characters are not needed, mostly for regular expressions</li><li>attributes - associating essentially arbitrary information with a name</li><li>lambdas - unnamed function objects</li><li>variadic templates - templates that can handle an arbitrary number of arguments of arbitrary types</li><li>template aliases - the ability to rename a template and to bind some template arguments for the new name</li><li>noexcept - a way of ensuring that an exception isn’t thrown from a function</li><li>override and final - explicit syntax for managing large class hierarchies</li><li>static_assert - compile-time assertions</li><li>long long - a longer integer type</li><li>default member initializers - give a data member a default value that can be superseded by initialization in a constructor</li><li>enum classes - strongly typed enumerations with scoped enumerators</li></ul><p>And here is a list of the major standard-library components:</p><ul><li>unique_ptr and shared_ptr - resource-management pointers relying on RAII</li><li>memory model and atomic variables</li><li>thread, mutex, condition_variable, etc. - type-safe and portable support for basic system- level concurrency</li><li>future, promise, and packaged_task, etc. - slightly higher-level concurrency</li><li>tuple - unnamed simple composite types</li><li>type traits - testable properties of types for use in metaprogramming</li><li>regular expression matching</li><li>random numbers - with many generators (engines) and distributions</li><li>Time - time_point and duration</li><li>unordered_map, etc. - hash tables</li><li>forward_list - a singly-linked list</li><li>array - a fixed-constant-sized array that knows its size</li><li>emplace operations - construct objects right within a container to avoid copying</li><li>exception_ptr - enables transfer of exceptions between threads</li></ul></details><details class="details custom-block"><summary>C++17 features</summary><p>C++17 had about 21 new language features (depending on how you count), including:</p><ul><li>Constructor template argument deduction - simplify object definitions</li><li>Deduction guides - an explicit notation for resolving constructor template argument deduction ambiguities</li><li>Structured bindings - simplify notation and eliminate a source of uninitialized variables</li><li>inline variables - simplify the use of statically allocated variables in header-only libraries</li><li>Fold expressions - simplify some uses of variadic templates</li><li>Explicit test in conditions - a bit like conditions in for-statements</li><li>Guaranteed copy elision - eliminate many redundant copy operations</li><li>Stricter expression evaluation order - prevents some subtle order-of-evaluation mistakes</li><li>auto as a template argument type - type deduction for value template arguments</li><li>Standard attributes to catch common mistakes - <code>[[maybe_unused]]</code>, <code>[[nodiscard]]</code>, and <code>[[fallthrough]]</code></li><li>Hexadecimal floating-point literals</li><li>Constant expression if - simplify compile-time evaluated code</li></ul><p>The C++17 standard-library added about 13 new features plus many minor modifications:</p><ul><li>optional, variant, and any - standard-library types for expressing alternatives</li><li>shared_mutex and shared_lock (reader-writer locks) and scoped_lock</li><li>parallel STL - multi-threaded and/or vectorized versions of standard-library algorithms</li><li>file system - the ability to portably manipulate file-system paths and directories</li><li>string_view - a non-owning reference to an immutable sequence of characters</li><li>Mathematical special functions - including Laguerre and Legendre polynomials, beta func- tions, Riemann zeta function</li></ul></details>`,54)]))}const g=s(l,[["render",e]]);export{c as __pageData,g as default};

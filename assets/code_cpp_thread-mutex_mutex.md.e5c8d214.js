import{_ as s,c as n,o as a,Q as l}from"./chunks/framework.1cc28bed.js";const F=JSON.parse('{"title":"各种锁","description":"","frontmatter":{},"headers":[],"relativePath":"code/cpp/thread-mutex/mutex.md","filePath":"code/cpp/thread-mutex/mutex.md","lastUpdated":1682241312000}'),p={name:"code/cpp/thread-mutex/mutex.md"},o=l(`<h1 id="各种锁" tabindex="-1">各种锁 <a class="header-anchor" href="#各种锁" aria-label="Permalink to &quot;各种锁&quot;">​</a></h1><h2 id="mutex" tabindex="-1">mutex <a class="header-anchor" href="#mutex" aria-label="Permalink to &quot;mutex&quot;">​</a></h2><p>在多线程程序中，线程之间会共享访问同一个内存空间。这种共享访问可能导致各种问题，例如竞争条件、数据不一致等。为了解决这些问题，我们可以使用互斥量（mutex）进行同步。</p><p>互斥量是指一种特殊的线程同步对象，它可以保证同一时刻只有一个线程能够访问某个共享资源。在C++标准库中，互斥量类型是<code>std::mutex</code>。使用互斥量的基本流程如下：</p><ol><li>在需要同步的代码段之前，锁定互斥量，这个过程称为加锁。</li><li>执行需要同步的代码段。</li><li>在需要同步的代码段之后，解锁互斥量，这个过程称为解锁。</li></ol><p>例如，下面是一个使用互斥量的示例程序：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">#include</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&lt;iostream&gt;</span></span>
<span class="line"><span style="color:#F97583;">#include</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&lt;mutex&gt;</span></span>
<span class="line"><span style="color:#F97583;">#include</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&lt;thread&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::mutex mutex;</span></span>
<span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> value </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">increment</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">  mutex.</span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">value;</span></span>
<span class="line"><span style="color:#E1E4E8;">  mutex.</span><span style="color:#B392F0;">unlock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::thread </span><span style="color:#B392F0;">t1</span><span style="color:#E1E4E8;">(increment);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::thread </span><span style="color:#B392F0;">t2</span><span style="color:#E1E4E8;">(increment);</span></span>
<span class="line"><span style="color:#E1E4E8;">  t1.</span><span style="color:#B392F0;">join</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">  t2.</span><span style="color:#B392F0;">join</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::cout </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> value </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::endl;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">#include</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&lt;iostream&gt;</span></span>
<span class="line"><span style="color:#D73A49;">#include</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&lt;mutex&gt;</span></span>
<span class="line"><span style="color:#D73A49;">#include</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&lt;thread&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::mutex mutex;</span></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> value </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">increment</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  mutex.</span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">++</span><span style="color:#24292E;">value;</span></span>
<span class="line"><span style="color:#24292E;">  mutex.</span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::thread </span><span style="color:#6F42C1;">t1</span><span style="color:#24292E;">(increment);</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::thread </span><span style="color:#6F42C1;">t2</span><span style="color:#24292E;">(increment);</span></span>
<span class="line"><span style="color:#24292E;">  t1.</span><span style="color:#6F42C1;">join</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">  t2.</span><span style="color:#6F42C1;">join</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::cout </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> value </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::endl;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在这个程序中，我们定义了一个全局变量value和一个函数increment，它会将value加一。然后我们创建了两个线程，分别执行函数increment。由于两个线程会同时执行这个函数，所以在函数内部，我们使用互斥量mutex进行加锁和解锁，以保证在任何时刻，只有一个线程能够访问value。</p><p>在这个程序中，我们使用了互斥量的两个方法：lock和unlock。lock方法用于加锁，如果互斥量当前没有被锁定，那么调用这个方法会锁定互斥量，并立即返回；如果互斥量当前已经被锁定，那么调用这个方法会阻塞线程，直到互斥量被解锁为止。unlock方法用于解锁，如果互斥量当前已经被锁定，那么调用这个方法会解锁互斥量，并立即返回；如果互斥量当前没有被锁定，那么调用这个方法会抛出一个异常。</p><p>总之，互斥量是多线程程序中一种重要的同步工具，它可以保证同一时刻只有一个线程能够访问某个共享资源。使用互斥量的流程是：首先在需要同步的代码段之前，锁定互斥量；然后执行需要同步的代码段；最后在需要同步的代码段之后，解锁互斥量。</p><h2 id="一般在c-开发中-都会使用哪些锁-请就实际开发角度举例-在什么样的情况下使用适合使用什么类型的锁" tabindex="-1">一般在c++ 开发中, 都会使用哪些锁? 请就实际开发角度举例, 在什么样的情况下使用适合使用什么类型的锁 <a class="header-anchor" href="#一般在c-开发中-都会使用哪些锁-请就实际开发角度举例-在什么样的情况下使用适合使用什么类型的锁" aria-label="Permalink to &quot;一般在c++ 开发中, 都会使用哪些锁? 请就实际开发角度举例, 在什么样的情况下使用适合使用什么类型的锁&quot;">​</a></h2><p>一些常见的锁类型包括：</p><ul><li>互斥锁：互斥锁是一种锁，用于确保任何时候只有一个线程（或进程）能够访问共享资源。这种锁通常用于多个线程需要访问共享资源，但是该资源在任何时候只能由一个线程使用的情况。例如，可以使用互斥锁来同步对共享文件或数据库的访问。</li><li>读写锁：读写锁允许多个线程同时读取共享资源，但在任何时候只允许一个线程写入资源。当共享资源被读取的次数多于写入的次数时，这种锁非常有用，因为它允许多个线程同时读取资源，从而提高性能。</li><li>信号量：信号量是一种锁，用于控制对有限数量共享资源的访问。例如，可以使用信号量来限制同时访问共享数据库连接池的线程数量。</li><li>自旋锁：自旋锁是一种锁，用于在尝试获取锁的线程预计会很快释放锁的情况下。在这种情况下，自旋锁会“自旋”（即不断检查）来查看锁是否可用，而不是睡眠并等待锁被释放。在某些情况下，这可以提高性能，但如果线程释放锁的时间过长，也可能导致性能问题。</li></ul><p>总的来说，在特定情况下使用哪种锁取决于应用程序的具体要求和限制。一般来说，选择最适合应用程序特定需求的锁类型，可以确保高效和正确地同步访问共享资源。</p>`,14),e=[o];function t(c,r,E,y,i,d){return a(),n("div",null,e)}const m=s(p,[["render",t]]);export{F as __pageData,m as default};

import{_ as l,c as a,o as e,Q as i}from"./chunks/framework.1cc28bed.js";const m=JSON.parse('{"title":"C 与 C++","description":"","frontmatter":{},"headers":[],"relativePath":"code/cpp/c-cpp-diff.md","filePath":"code/cpp/c-cpp-diff.md","lastUpdated":1682241312000}'),t={name:"code/cpp/c-cpp-diff.md"},r=i('<h1 id="c-与-c" tabindex="-1">C 与 C++ <a class="header-anchor" href="#c-与-c" aria-label="Permalink to &quot;C 与 C++&quot;">​</a></h1><h2 id="简单版本" tabindex="-1">简单版本 <a class="header-anchor" href="#简单版本" aria-label="Permalink to &quot;简单版本&quot;">​</a></h2><ul><li>C++是面向对象的语言，而C是面向过程的语言</li><li>C++引入new/delete运算符，取代了C中的malloc/free库函数</li><li>C++引入引用的概念，而C中没有</li><li>C++引入类的概念，而C中没有</li><li>C++引入函数重载的特性，而C中没有</li></ul><h2 id="标准" tabindex="-1">标准 <a class="header-anchor" href="#标准" aria-label="Permalink to &quot;标准&quot;">​</a></h2><p>分别隶属于两个不同的标准委员会。C以C99标准为主流，C11已经发布；C++以C++98/03为主流，C++11/14也日趋流行。</p><h2 id="语言本身" tabindex="-1">语言本身 <a class="header-anchor" href="#语言本身" aria-label="Permalink to &quot;语言本身&quot;">​</a></h2><ul><li>C++是面向对象语言，C是面向过程语言。</li><li>结构：C以结构体struct为核心结构；C++以类class为核心结构。</li><li>多态：C可以以宏定义的方式“自定义”部分地支持多态；C++自身提供多态，并以模板templates支持编译期多态，以虚函数virtual function支持运行期多态。</li><li>头文件的调用：C++用&lt; &gt;代替” “代表系统头文件；且复用C的头文件时，去掉”.h”在开头加上”C”。</li><li>输入输出：鉴于C++中以对象作为核心，输入和输出都是在流对象上的操作。</li><li>封装：C中的封装由于struct的特性全部为公有封装，C++中的封装由于class的特性更加完善、安全。</li><li>常见风格：C中常用宏定义来进行文本替换，不具有类型安全性；C++中常建议采用常量定义，具有类型安全性。</li><li>效率：常见的说法是同等目的C通常比C++更富有效率( 这其实有一定的误解，主要在于C++代码更难于优化且少有人使用编译期求值的特性)。</li><li>常用语言/库特性：</li><li>数组：C中采用内建数组，C++中建议采用vector。相比之下vector的大小可以动态增长，且使用一些技巧后增长并不低效，且成员函数丰富。</li><li>字符串 C中采用C风格的string(实则为字符串数组)，C++中建议采用string，对比与上一条类似。</li><li>内存分配：C中使用malloc与free，它们是是C标准库函数，C++中建议使用new/delete代替前者，他们说是C++的运算符( 这是笔试面试常考点)以C++中的new为例，new可分为operator new(new 操作)、new operator(new 操作符)和placement new(定位 new) 。其中operator new执行和malloc相同的任务，即分配内存，但对构造函数一无所知；而 new operator则调用operator new，分配内存后再调用对象构造函数进行对象的构造。其中operator new是可以重载的。placement new，就是operator new的一个重载版本，允许你在一个已经分配好的内存中构造一个新的对象。</li><li>指针：C中通常使用的是原生指针(raw pointer) ，由于常出现程序员在申请后忘记释放造成资源泄漏的问题，在C++98中加入了“第一代”基于引用计数的智能指针auto_ptr，由于初代的各种问题( 主要是无法解决循环指针)，在03标准也就是TR1中引入了shared_ptr,weak_ptr和unique_ptr这三个功能各异的智能指针，并与11标准中正式确定，较好的解决了上述问题。</li></ul><h2 id="仅有c-才有的常用特性" tabindex="-1">仅有C++才有的常用特性 <a class="header-anchor" href="#仅有c-才有的常用特性" aria-label="Permalink to &quot;仅有C++才有的常用特性&quot;">​</a></h2><h3 id="语言-范式-特性" tabindex="-1">语言(范式)特性 <a class="header-anchor" href="#语言-范式-特性" aria-label="Permalink to &quot;语言(范式)特性&quot;">​</a></h3><ul><li>面向对象编程：C++中以关键字class和多态特性支持的一种编程范式；</li><li>泛型编程：C++中以关键字template支持的一种编程范式；</li><li>模板元编程 ：C++中以模板特化和模板递归调用机制支持的一种编程范式。</li><li>C++中以对象和类型作为整个程序的核心，在对象方面，时刻注意对象创建和析构的成本，例如有一个很常用的(具名)返回值优化((N) RVO); 在类型方面，有运行时类型信息(RTTI)等技术作为C++类型技术的支撑。</li><li>函数重载：C++允许拥有不同变量但具有相同函数名的函数(函数重载的编译器实现方式、函数重载和(主)模板特化的区别都曾考过)。</li><li>异常：以catch、throw、try等关键字支持的一种机制。</li><li>命名空间：namespace，可以避免和减少命名冲突且让代码具有更强的可读性。</li><li>谓词用法：通常以bool函数或仿函数(functor)或lambda函数的形式，出现在STL的大多数算法的第三个元素。</li></ul><h3 id="常见关键字-操作符-特性" tabindex="-1">常见关键字(操作符)特性 <a class="header-anchor" href="#常见关键字-操作符-特性" aria-label="Permalink to &quot;常见关键字(操作符)特性&quot;">​</a></h3><ul><li>auto：在C中，auto代表自动类型通常都可省略；而在C++11新标准中，则起到一种“动态类型”的作用——通常在自动类型推导和decltype搭配使用。</li><li>空指针：在C中常以NULL代表空指针，在C++中根据新标准用nullptr来代表空指针。</li><li>&amp;: 在C中仅代表取某个左值(lvalue)的地址，在C++中还可以表示引用(别名)。</li><li>&amp;&amp;：在C中仅能表示逻辑与，在C++中还可以表示右值引用。</li><li>[]：在C中仅能表示下标操作符，在C++中还可以表示lambda函数的捕捉列表。</li><li>{}：在C中仅能用于数组的初始化，在C++中由于引入了初始化列表(initializer_list)，可用于任何类型、容器等的初始化。</li><li>常量定义：C中常以define来定义常量，C++中用const来定义运行期常量，用constexpr来定义编译器常量。</li></ul><h3 id="常用新特性" tabindex="-1">常用新特性 <a class="header-anchor" href="#常用新特性" aria-label="Permalink to &quot;常用新特性&quot;">​</a></h3><ul><li>右值引用和move语义(太多内容，建议自查)。</li><li>基于范围的for循环(与python中的写法类似，常用于容器)。</li><li>基于auto——decltype的自动类型推导。</li><li>lambda函数(一种局部、匿名函数，高效方便地出现在需要局部、匿名语义的地方)。</li><li>标准规范后的多线程库。</li></ul>',14),o=[r];function C(c,n,d,s,p,h){return e(),a("div",null,o)}const _=l(t,[["render",C]]);export{m as __pageData,_ as default};

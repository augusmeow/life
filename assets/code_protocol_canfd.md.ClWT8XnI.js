import{_ as e,c as a,a3 as l,o as r}from"./chunks/framework.DDs3IadZ.js";const i="/life/img/code/protocol/can-fd-frame.png",x=JSON.parse('{"title":"CAN FD","description":"","frontmatter":{},"headers":[],"relativePath":"code/protocol/canfd.md","filePath":"code/protocol/canfd.md","lastUpdated":1716450709000}'),n={name:"code/protocol/canfd.md"};function d(o,t,c,s,h,C){return r(),a("div",null,t[0]||(t[0]=[l('<h1 id="can-fd" tabindex="-1">CAN FD <a class="header-anchor" href="#can-fd" aria-label="Permalink to &quot;CAN FD&quot;">​</a></h1><h2 id="concepts" tabindex="-1">concepts <a class="header-anchor" href="#concepts" aria-label="Permalink to &quot;concepts&quot;">​</a></h2><ul><li>CAN-FD – Controller Area Network with Flexible Data-rate</li><li>RRS – Remote Request Substitution</li><li>IDE – IDentifier Extension</li><li>FDF – FD Format Indicator</li><li>res – Reserved bit in FD frames</li><li>BRS – Bit Rate Switch</li><li>ESI – Error State Indicator</li><li>DLC – Data Length Code</li></ul><h2 id="tutorial-links" tabindex="-1">tutorial links <a class="header-anchor" href="#tutorial-links" aria-label="Permalink to &quot;tutorial links&quot;">​</a></h2><ul><li><a href="https://kvaser.com/can-protocol-tutorial/" target="_blank" rel="noreferrer">CAN tutorial by Kvaser</a></li><li><a href="https://kvaser.com/can-fd-protocol-tutorial/" target="_blank" rel="noreferrer">CAN FD tutorial by Kvaser</a></li></ul><h2 id="cases" tabindex="-1">cases <a class="header-anchor" href="#cases" aria-label="Permalink to &quot;cases&quot;">​</a></h2><ul><li><a href="https://github.com/OpenCyphal/libcanard/" target="_blank" rel="noreferrer">OpenCyphal/libcanard</a></li></ul><h2 id="diff-can-fd-flexray" tabindex="-1">diff can-fd &amp; flexray <a class="header-anchor" href="#diff-can-fd-flexray" aria-label="Permalink to &quot;diff can-fd &amp; flexray&quot;">​</a></h2><p>CAN FD XL 和 FlexRay 是两种用于汽车和工业应用的通信协议。它们各有优缺点，设计目标和使用场景也有所不同。</p><p>CAN FD XL</p><p>CAN FD（Controller Area Network with Flexible Data-rate）XL 是标准 CAN 协议的扩展版本，它旨在克服传统 CAN 协议的一些限制，特别是在数据速率和数据量方面。CAN FD XL 是指 CAN FD 协议的进一步扩展，通常用于描述新一代的 CAN 技术，它包含以下特点：</p><p>更高的数据速率：相比传统 CAN 的最高 1 Mbps，CAN FD 支持高达 5 Mbps（在特定条件下甚至更高）。<br> 更大的数据帧：传统 CAN 帧的数据长度限制为 8 字节，而 CAN FD 可扩展至 64 字节。<br> 灵活的数据率：数据部分和仲裁部分可以使用不同的数据速率，提高了通信效率。<br> 向后兼容：能够与传统 CAN 节点共存，允许在同一总线上运行混合的传统 CAN 和 CAN FD 设备。</p><p>CAN FD XL 特别适用于需要更高吞吐量和更大数据帧的应用场景，比如复杂的电子控制单元（ECU）之间的通信、高频数据采集和传输等。</p><p>FlexRay</p><p>FlexRay 是另一种高级的汽车通信总线标准，由 FlexRay Consortium 开发，特别适用于高数据率和高可靠性的应用场景。其特点如下：</p><p>高数据速率：支持高达 10 Mbps 的数据传输速率，比传统 CAN 更快，适合实时性要求高的应用。<br> 双通道冗余：FlexRay 一般提供双通道通信，这增加了系统的可靠性和容错能力。即使一个通道发生故障，通信仍可通过另一个通道进行。<br> 灵活的时间调度：支持静态和动态时间分段（TDMA 和 FTDMA），可以满足不同数据帧的实时传输需求。<br> 确定性传输：FlexRay 提供确定性的通信时间，这对实时性要求高的安全关键型应用非常重要，如高级驾驶辅助系统（ADAS）和自动驾驶功能。<br> 高可靠性：设计上具备高鲁棒性，抗干扰能力强，适用于关键任务和安全相关的系统。</p><p>FlexRay 通常用于比 CAN FD 更苛刻的环境和应用场景，如自动驾驶车辆、底盘控制、动力传动系统等，在这些场景中数据量大、实时性和可靠性要求高。</p><p>总结而言，CAN FD XL 和 FlexRay 各有所长，选择哪种协议取决于具体的应用需求、性能要求和系统架构。CAN FD XL 更适用于需要较高数据速率和灵活性的系统，而 FlexRay 则适用于需要极高可靠性和确定性时间调度的应用场景。</p><h2 id="帧格式" tabindex="-1">帧格式 <a class="header-anchor" href="#帧格式" aria-label="Permalink to &quot;帧格式&quot;">​</a></h2><p>7 部分<br> SOF(Start of Frame) 帧起始，Arbitration Field 仲裁场，Control Field 控制场，Data Field 数据场，CRC Field(Stuff Count + CRC Sequence)，ACK Field，EOF(End of Frame) 帧结束</p><p><img src="'+i+'" alt="alt"></p><h3 id="sof" tabindex="-1">SOF <a class="header-anchor" href="#sof" aria-label="Permalink to &quot;SOF&quot;">​</a></h3><p>CAN, CAN FD 均使用显性 1 bit SOF</p><h3 id="arbitration-field" tabindex="-1">Arbitration Field <a class="header-anchor" href="#arbitration-field" aria-label="Permalink to &quot;Arbitration Field&quot;">​</a></h3><p>ID: 相同，标准ID/扩展ID，11位<br> CAN：RTR 1位，CAN FD：RSS 1位</p><h3 id="control-field" tabindex="-1">Control Field <a class="header-anchor" href="#control-field" aria-label="Permalink to &quot;Control Field&quot;">​</a></h3><p>CAN, CAN FD 的 IDE(1bit), res(1bit), DLC(4bits) 位相同</p><p>CAN FD 增加：</p><ul><li>FDF：FD 格式位，隐性(CAN FD)，显性(CAN)</li><li>BRS：速率切换位，隐性（切换可变速率），显性（不切换）</li><li>ESI：错误状态指示位，隐性（主动错误），显性（被动错误）</li></ul><p>DLC（Data Length Code，数据长度码）是一个重要的字段，用于指示数据帧中的数据字节数。然而，与经典CAN的DLC不同，CAN FD中的DLC有一些新的特点和扩展。</p><p>在经典CAN和CAN FD中，DLC字段位于CAN帧的控制字段中，其主要功能是指示数据字段中包含的数据字节数。</p><p>在CAN FD中，DLC的值可以取0到15，并且根据DLC值，实际的数据字节数可以从0到64个字节不等。<br> DLC值为0到8时，实际的数据字节数对应DLC的值。<br> DLC值为9到15时，实际的数据字节数对应特定的预定义长度。</p><p>下面是一个DLC值与实际数据字节数的映射表：</p><table tabindex="0"><thead><tr><th style="text-align:center;">DLC</th><th style="text-align:center;">DLC(bin)</th><th style="text-align:center;">数据字节数</th></tr></thead><tbody><tr><td style="text-align:center;">0</td><td style="text-align:center;">0000</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">1</td><td style="text-align:center;">0001</td><td style="text-align:center;">1</td></tr><tr><td style="text-align:center;">2</td><td style="text-align:center;">0010</td><td style="text-align:center;">2</td></tr><tr><td style="text-align:center;">3</td><td style="text-align:center;">0011</td><td style="text-align:center;">3</td></tr><tr><td style="text-align:center;">4</td><td style="text-align:center;">0100</td><td style="text-align:center;">4</td></tr><tr><td style="text-align:center;">5</td><td style="text-align:center;">0101</td><td style="text-align:center;">5</td></tr><tr><td style="text-align:center;">6</td><td style="text-align:center;">0110</td><td style="text-align:center;">6</td></tr><tr><td style="text-align:center;">7</td><td style="text-align:center;">0111</td><td style="text-align:center;">7</td></tr><tr><td style="text-align:center;">8</td><td style="text-align:center;">1000</td><td style="text-align:center;">8</td></tr><tr><td style="text-align:center;">9</td><td style="text-align:center;">1001</td><td style="text-align:center;">12</td></tr><tr><td style="text-align:center;">10</td><td style="text-align:center;">1010</td><td style="text-align:center;">16</td></tr><tr><td style="text-align:center;">11</td><td style="text-align:center;">1011</td><td style="text-align:center;">20</td></tr><tr><td style="text-align:center;">12</td><td style="text-align:center;">1100</td><td style="text-align:center;">24</td></tr><tr><td style="text-align:center;">13</td><td style="text-align:center;">1101</td><td style="text-align:center;">32</td></tr><tr><td style="text-align:center;">14</td><td style="text-align:center;">1110</td><td style="text-align:center;">48</td></tr><tr><td style="text-align:center;">15</td><td style="text-align:center;">1111</td><td style="text-align:center;">64</td></tr></tbody></table><h3 id="data-field" tabindex="-1">Data Field <a class="header-anchor" href="#data-field" aria-label="Permalink to &quot;Data Field&quot;">​</a></h3><p>CAN: 0-8 Bytes<br> CAN FD: 0-8, 12, 16, 20, 24, 32, 48, 64 Bytes<br> 数据场里低字节先发 Byte0...Byte7<br> 每个字节高位先发 bit7...bit0<br> DLC=0 无数据场</p><h3 id="crc-field" tabindex="-1">CRC Field <a class="header-anchor" href="#crc-field" aria-label="Permalink to &quot;CRC Field&quot;">​</a></h3><p>Stuff Count: 4位，CAN 中不使用该填充位<br> 表示在 CRC Sequence 前填充位的数量，模8算法以3位格雷码和一位奇偶校验码存储</p><div class="info custom-block"><p class="custom-block-title">格雷码</p><p>最高位保留，次高位为二进制最高位与次高位异或运算结果</p></div><p>CRC Sequence</p><h3 id="ack-field" tabindex="-1">ACK Field <a class="header-anchor" href="#ack-field" aria-label="Permalink to &quot;ACK Field&quot;">​</a></h3><h3 id="eof" tabindex="-1">EOF <a class="header-anchor" href="#eof" aria-label="Permalink to &quot;EOF&quot;">​</a></h3>',42)]))}const b=e(n,[["render",d]]);export{x as __pageData,b as default};

import{_ as s,c as a,o as n,Q as l}from"./chunks/framework.1cc28bed.js";const v=JSON.parse('{"title":"STL","description":"","frontmatter":{},"headers":[],"relativePath":"code/cpp/concept/stl.md","filePath":"code/cpp/concept/stl.md","lastUpdated":1697180748000}'),p={name:"code/cpp/concept/stl.md"},t=l(`<h1 id="stl" tabindex="-1">STL <a class="header-anchor" href="#stl" aria-label="Permalink to &quot;STL&quot;">​</a></h1><p><a href="https://zintrulcre.vip/posts/cpp/basics/basics/#%E6%89%80%E6%9C%89%E5%AE%B9%E5%99%A8" target="_blank" rel="noreferrer">refer</a></p><table><thead><tr><th style="text-align:left;">容器</th><th style="text-align:left;">实现</th><th style="text-align:left;">查询</th><th style="text-align:left;">插入删除</th><th style="text-align:left;">特点</th></tr></thead><tbody><tr><td style="text-align:left;">array</td><td style="text-align:left;">数组</td><td style="text-align:left;">O(1)</td><td style="text-align:left;">O(1)</td><td style="text-align:left;">大小固定</td></tr><tr><td style="text-align:left;">vector</td><td style="text-align:left;">数组</td><td style="text-align:left;">O(1)</td><td style="text-align:left;">尾部 O(1)，其他 O(n)</td><td style="text-align:left;">大小可变，扩容耗时</td></tr><tr><td style="text-align:left;">deque</td><td style="text-align:left;">双端队列</td><td style="text-align:left;">O(n)</td><td style="text-align:left;">头尾 O(1)，其他 O(n)</td><td style="text-align:left;">一个中央控制器，多个缓冲区</td></tr><tr><td style="text-align:left;">list</td><td style="text-align:left;">双向链表</td><td style="text-align:left;">O(n)</td><td style="text-align:left;">O(1)</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">forward_list</td><td style="text-align:left;">单向链表</td><td style="text-align:left;">O(n)</td><td style="text-align:left;">O(1)</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">stack</td><td style="text-align:left;">deque / list</td><td style="text-align:left;">/</td><td style="text-align:left;">O(1)</td><td style="text-align:left;">先进后出</td></tr><tr><td style="text-align:left;">queue</td><td style="text-align:left;">deque / list</td><td style="text-align:left;">/</td><td style="text-align:left;">O(1)</td><td style="text-align:left;">先进先出</td></tr><tr><td style="text-align:left;">priority_queue</td><td style="text-align:left;">vector</td><td style="text-align:left;">/</td><td style="text-align:left;">O(logn) 堆，完全二叉树</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">set</td><td style="text-align:left;">红黑树</td><td style="text-align:left;">O(logn)</td><td style="text-align:left;">O(logn)</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">multiset</td><td style="text-align:left;">红黑树</td><td style="text-align:left;">O(logn)</td><td style="text-align:left;">O(logn)</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">map</td><td style="text-align:left;">红黑树</td><td style="text-align:left;">O(logn)</td><td style="text-align:left;">O(logn)</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">multimap</td><td style="text-align:left;">红黑树</td><td style="text-align:left;">O(logn)</td><td style="text-align:left;">O(logn)</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">unordered_set</td><td style="text-align:left;">哈希表</td><td style="text-align:left;">平均 O(1)</td><td style="text-align:left;">平均 O(1)</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">unordered_multiset</td><td style="text-align:left;">哈希表</td><td style="text-align:left;">平均 O(1)</td><td style="text-align:left;">平均 O(1)</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">unordered_map</td><td style="text-align:left;">哈希表</td><td style="text-align:left;">平均 O(1)</td><td style="text-align:left;">平均 O(1)</td><td style="text-align:left;"></td></tr><tr><td style="text-align:left;">unordered_multimap</td><td style="text-align:left;">哈希表</td><td style="text-align:left;">平均 O(1)</td><td style="text-align:left;">平均 O(1)</td><td style="text-align:left;"></td></tr></tbody></table><h2 id="常用的容器有哪些" tabindex="-1">常用的容器有哪些 <a class="header-anchor" href="#常用的容器有哪些" aria-label="Permalink to &quot;常用的容器有哪些&quot;">​</a></h2><p>STL（Standard Template Library，标准模板库）是C++语言的一个重要组成部分，它提供了一组用于管理内存和容器数据结构的模板类。STL中常用的容器包括：</p><ul><li>vector：动态数组，可以存储任意类型的对象。</li><li>deque：双端队列，可以在队列两端进行插入和删除操作。</li><li>list：双向链表，可以在链表中任意位置进行插入和删除操作。</li><li>set：集合，可以存储不重复的元素，并支持快速查找。</li><li>map：映射，可以存储键值对，并支持快速查找。</li></ul><p>除了上述容器之外，STL还包括许多其他容器，例如<code>stack</code>、<code>queue</code>、<code>priority_queue</code>等。程序员可以根据实际需要选择适当的容器来管理内存和数据。</p><h2 id="简述-vector-的实现原理" tabindex="-1">简述 vector 的实现原理 <a class="header-anchor" href="#简述-vector-的实现原理" aria-label="Permalink to &quot;简述 vector 的实现原理&quot;">​</a></h2><p>Vector 是一种数据结构，它的实现原理是将数据存储在一个连续的内存空间中，以便更快地访问和修改数据。与数组不同，Vector 可以自动扩展和收缩，以便存储更多的数据。由于 Vector 在内存中连续存储数据，所以它可以更快地进行读写操作，比数组更加高效。</p><h2 id="stl-中-vector-与-list-具体是怎么实现的-常见操作的时间复杂度是多少" tabindex="-1">STL 中 vector 与 list 具体是怎么实现的？常见操作的时间复杂度是多少？ <a class="header-anchor" href="#stl-中-vector-与-list-具体是怎么实现的-常见操作的时间复杂度是多少" aria-label="Permalink to &quot;STL 中 vector 与 list 具体是怎么实现的？常见操作的时间复杂度是多少？&quot;">​</a></h2><p>vector 是一种数组，其中的数据是连续存储在内存中的。因此，vector 是一个顺序容器，可以快速随机访问其中的元素。vector 的内部实现是一个动态数组，它会在需要的时候自动扩展或缩小，以适应存储的数据量。</p><p>list 是一种链表，它的内部实现是一个单向链表。因此，list 是一个链式容器，可以高效地插入和删除元素。list 的内存分配方式和 vector 不同，它会为每个元素在内存中分配一个独立的空间，因此它可以存储不连续的数据。</p><p>在 STL 中，vector 和 list 的常见操作的时间复杂度通常如下：</p><p>vector:</p><ul><li>在 vector 的末尾插入或删除元素：O(1)（常数时间）</li><li>在 vector 的中间插入或删除元素：O(n)（线性时间）</li><li>访问 vector 中的元素：O(1)（常数时间） list:</li><li>在 list 的末尾插入或删除元素：O(1)</li></ul><h2 id="c-的-vector-和-list中-如果删除末尾的元素-其指针和迭代器如何变化-若删除的是中间的元素呢" tabindex="-1">C++ 的 vector 和 list中，如果删除末尾的元素，其指针和迭代器如何变化？若删除的是中间的元素呢？ <a class="header-anchor" href="#c-的-vector-和-list中-如果删除末尾的元素-其指针和迭代器如何变化-若删除的是中间的元素呢" aria-label="Permalink to &quot;C++ 的 vector 和 list中，如果删除末尾的元素，其指针和迭代器如何变化？若删除的是中间的元素呢？&quot;">​</a></h2><p>在 C++ 的 vector 和 list 中，如果删除的是末尾的元素，那么容器的大小会减少 1，所有指向容器末尾的指针和迭代器都会失效。但指向容器内部的指针和迭代器不会发生变化，仍然可以正常使用。</p><p>如果删除的是容器中间的元素，那么容器的大小也会减少 1，所有指向容器中间被删除元素的指针和迭代器都会失效。而指向容器内部其它位置的指针和迭代器可能会发生变化，例如在 vector 中，它们的位置会向前移动，因为被删除的元素会导致整个容器向前移动。因此，在删除容器中间元素时，需要格外小心，以避免导致指针和迭代器失效。</p><h2 id="vector-的-reserve-和-capacity-的区别" tabindex="-1">vector 的 reserve 和 capacity 的区别? <a class="header-anchor" href="#vector-的-reserve-和-capacity-的区别" aria-label="Permalink to &quot;vector 的 reserve 和 capacity 的区别?&quot;">​</a></h2><p>reserve()用于让容器预留空间，避免再次内存分配；capacity() 返回在重新进行内存分配以前所能容纳的元素数量。</p><h2 id="auto-ptr-能作为-vector-的元素吗-为什么" tabindex="-1">auto_ptr 能作为 vector 的元素吗？为什么？ <a class="header-anchor" href="#auto-ptr-能作为-vector-的元素吗-为什么" aria-label="Permalink to &quot;auto_ptr 能作为 vector 的元素吗？为什么？&quot;">​</a></h2><p>不可以。 当复制一个 <code>auto_ptr</code> 时，它所指向的对象的所有权被交到复制的 <code>auto_ptr</code> 上面，而它自身将被设置为 null。复制一个 <code>auto_ptr</code> 意味着改变它的值。</p><h2 id="vector-里可以存放引用吗-可以存放指针吗" tabindex="-1">vector 里可以存放引用吗？可以存放指针吗 <a class="header-anchor" href="#vector-里可以存放引用吗-可以存放指针吗" aria-label="Permalink to &quot;vector 里可以存放引用吗？可以存放指针吗&quot;">​</a></h2><p><code>std::vector</code>不能直接存储引用。因为引用必须在创建时被初始化，并且它不能改变以引用别的对象。所以如果你尝试创建一个引用的向量，你会遇到问题，因为向量需要能够在内部进行拷贝和赋值操作，而引用不能这样做。</p><p>然而，<code>std::vector</code>可以存储指针。指针可以被复制和赋值，所以你可以使用它们在向量中存储对象的地址。但是，如果你这样做，你需要注意内存管理和生命周期的问题。当你在向量中存储指针时，向量不会自动管理你指向的对象的内存，你需要自己来管理这个内存。一旦你处理完这些对象，就需要自己删除它们以避免内存泄露。同时你还需要保证，在向量生命周期结束之前，指针所指向的对象仍然是存在的。</p><p>鉴于引用和指针的处理相对复杂，你还可以考虑使用<code>std::vector</code>来存储<code>std::shared_ptr</code>或者<code>std::unique_ptr</code>，这样可以利用智能指针自动处理内存管理的问题。</p><h2 id="stl中的vector-增减元素对迭代器的影响" tabindex="-1">STL中的vector：增减元素对迭代器的影响 <a class="header-anchor" href="#stl中的vector-增减元素对迭代器的影响" aria-label="Permalink to &quot;STL中的vector：增减元素对迭代器的影响&quot;">​</a></h2><p>在 STL 中的 vector 中，增加或删除元素对迭代器的影响取决于操作的位置。</p><p>如果在 vector 的末尾增加或删除元素，那么不会对迭代器产生任何影响。指向 vector 中任意位置的迭代器都会保持有效，并且可以继续正常使用。</p><p>如果在 vector 的中间增加或删除元素，那么会导致指向 vector 中间被操作位置的迭代器失效。如果是在 vector 中间插入元素，那么所有指向 vector 中间被插入元素后面的位置的迭代器都会失效，因为整个 vector 后续的元素都会向后移动。如果是在 vector 中间删除元素，那么所有指向 vector 中间被删除元素后面的位置的迭代器都会失效，因为整个 vector 后续的元素都会向前移动。</p><p>因此，在 STL 中的 vector 中，如果要在 vector 的中间增加或删除元素，需要特别小心，避免导致指向 vector 中间的迭代器失效。</p><h2 id="在模板中-如何声明嵌套从属类型-即模板嵌套类型" tabindex="-1">在模板中，如何声明嵌套从属类型(即模板嵌套类型)？ <a class="header-anchor" href="#在模板中-如何声明嵌套从属类型-即模板嵌套类型" aria-label="Permalink to &quot;在模板中，如何声明嵌套从属类型(即模板嵌套类型)？&quot;">​</a></h2><p>template内出现的类型如果依赖于某个template参数，则称之为从属类型；如果从属类型在class内呈嵌套状，则称之为嵌套从属类型。</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">template</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">typename</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">C</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">doSomething</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">C</span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">container</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(container.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">C</span><span style="color:#E1E4E8;">::iterator </span><span style="color:#B392F0;">iter</span><span style="color:#E1E4E8;">(container.</span><span style="color:#B392F0;">begin</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">template</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">typename</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">C</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">doSomething</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">C</span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;"> </span><span style="color:#E36209;">container</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(container.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">C</span><span style="color:#24292E;">::iterator </span><span style="color:#6F42C1;">iter</span><span style="color:#24292E;">(container.</span><span style="color:#6F42C1;">begin</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>此时，根据C++的规则，编译器先假设C::iterator不是一个类型。然而iter的声明只有在C::iterator是一个类型时才合理。因此需要我们自己告诉编译器。 那么，就需要再C:: iterator之前加上typename，告诉编译器C::iterator是一个类型。</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">template</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">typename</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">C</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">doSomething</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">C</span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">container</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(container.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">typename</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">C</span><span style="color:#E1E4E8;">::</span><span style="color:#B392F0;">iterator</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">iter</span><span style="color:#E1E4E8;">(container.</span><span style="color:#B392F0;">begin</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">template</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">typename</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">C</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">doSomething</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">C</span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;"> </span><span style="color:#E36209;">container</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(container.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">typename</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">C</span><span style="color:#24292E;">::</span><span style="color:#6F42C1;">iterator</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">iter</span><span style="color:#24292E;">(container.</span><span style="color:#6F42C1;">begin</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>如上就是。</p><h2 id="stl中排序算法的实现是什么" tabindex="-1">STL中排序算法的实现是什么 <a class="header-anchor" href="#stl中排序算法的实现是什么" aria-label="Permalink to &quot;STL中排序算法的实现是什么&quot;">​</a></h2><p>STL中的sort()，在数据量大时，采用quicksort，分段递归排序；一旦分段后的数量小于某个门限值，改用Insertion sort，避免quicksort深度递归带来的过大的额外负担，如果递归层次过深，还会改用heapsort。</p><h2 id="函数模板特化与重载决议中的陷阱" tabindex="-1">函数模板特化与重载决议中的陷阱 <a class="header-anchor" href="#函数模板特化与重载决议中的陷阱" aria-label="Permalink to &quot;函数模板特化与重载决议中的陷阱&quot;">​</a></h2><p>模板特化</p><ul><li>非特化的模板也被称为主模板；</li><li>类模板能全特化和偏特化；</li><li>函数模板只能全特化，不过由于函数重载的原因，能达到偏特化的效果。</li></ul><p>1和2中的f(p)分别会调用a、b、c中的哪一个？ 1和2中的f(p)分别会调用a、b、c中的哪一个？</p><ul><li><p>code1</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">template</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">typename</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">f</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">);</span><span style="color:#6A737D;">/* a */</span><span style="color:#E1E4E8;">          </span></span>
<span class="line"><span style="color:#F97583;">template</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">typename</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">f</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">T</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">);</span><span style="color:#6A737D;">/* b */</span><span style="color:#E1E4E8;">         </span></span>
<span class="line"><span style="color:#F97583;">template</span><span style="color:#E1E4E8;">&lt; &gt; </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">f</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">&gt;(</span><span style="color:#F97583;">int*</span><span style="color:#E1E4E8;">);</span><span style="color:#6A737D;">/* c */</span><span style="color:#E1E4E8;">           </span></span>
<span class="line"><span style="color:#F97583;">int*</span><span style="color:#E1E4E8;"> p;                                         </span></span>
<span class="line"><span style="color:#B392F0;">f</span><span style="color:#E1E4E8;">(p);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">template</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">typename</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">T</span><span style="color:#24292E;">&gt; </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">f</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">T</span><span style="color:#24292E;">);</span><span style="color:#6A737D;">/* a */</span><span style="color:#24292E;">          </span></span>
<span class="line"><span style="color:#D73A49;">template</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">typename</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">T</span><span style="color:#24292E;">&gt; </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">f</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">T</span><span style="color:#D73A49;">*</span><span style="color:#24292E;">);</span><span style="color:#6A737D;">/* b */</span><span style="color:#24292E;">         </span></span>
<span class="line"><span style="color:#D73A49;">template</span><span style="color:#24292E;">&lt; &gt; </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">f</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">&gt;(</span><span style="color:#D73A49;">int*</span><span style="color:#24292E;">);</span><span style="color:#6A737D;">/* c */</span><span style="color:#24292E;">           </span></span>
<span class="line"><span style="color:#D73A49;">int*</span><span style="color:#24292E;"> p;                                         </span></span>
<span class="line"><span style="color:#6F42C1;">f</span><span style="color:#24292E;">(p);</span></span></code></pre></div><p>这里，a是第一个主模板，b是第二个主模板，且b是第一个主模板a的重载而非偏特化(函数模板没有偏特化) 。c是第二个主模板b的显式特化(全特化)。 在f(p)调用时，发生重载决议，会无视特化存在( 标准规定：重载决议无视模板特化，重载决议只会发生在主模板之间)。在主模板a和b中决议出b，即第二个主模板被决议选中，然后再调用其全特化版本c。</p></li><li><p>code2</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">template</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">typename</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">f</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">);</span><span style="color:#6A737D;">/* a */</span></span>
<span class="line"><span style="color:#F97583;">template</span><span style="color:#E1E4E8;">&lt; &gt; </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">f</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">int*</span><span style="color:#E1E4E8;">&gt;(</span><span style="color:#F97583;">int*</span><span style="color:#E1E4E8;">);</span><span style="color:#6A737D;">/* b */</span></span>
<span class="line"><span style="color:#F97583;">template</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">typename</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">f</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">T</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">);</span><span style="color:#6A737D;">/* c */</span></span>
<span class="line"><span style="color:#F97583;">int*</span><span style="color:#E1E4E8;"> p;</span></span>
<span class="line"><span style="color:#B392F0;">f</span><span style="color:#E1E4E8;">(p);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">template</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">typename</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">T</span><span style="color:#24292E;">&gt; </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">f</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">T</span><span style="color:#24292E;">);</span><span style="color:#6A737D;">/* a */</span></span>
<span class="line"><span style="color:#D73A49;">template</span><span style="color:#24292E;">&lt; &gt; </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">f</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">int*</span><span style="color:#24292E;">&gt;(</span><span style="color:#D73A49;">int*</span><span style="color:#24292E;">);</span><span style="color:#6A737D;">/* b */</span></span>
<span class="line"><span style="color:#D73A49;">template</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">typename</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">T</span><span style="color:#24292E;">&gt; </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">f</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">T</span><span style="color:#D73A49;">*</span><span style="color:#24292E;">);</span><span style="color:#6A737D;">/* c */</span></span>
<span class="line"><span style="color:#D73A49;">int*</span><span style="color:#24292E;"> p;</span></span>
<span class="line"><span style="color:#6F42C1;">f</span><span style="color:#24292E;">(p);</span></span></code></pre></div><p>这里a是第一个主模板，b是第一个主模板a的全特化，c是第二个主模板。在f(p) 调用时，发生重载决议，同样会无视特化存在，在主模板a和c中决议出c，而c并无全特化版本，因此直接调用c。</p></li></ul><h2 id="相等和等价的区别-哪些类型的容器使用相等或等价" tabindex="-1">相等和等价的区别？哪些类型的容器使用相等或等价？ <a class="header-anchor" href="#相等和等价的区别-哪些类型的容器使用相等或等价" aria-label="Permalink to &quot;相等和等价的区别？哪些类型的容器使用相等或等价？&quot;">​</a></h2><ul><li>相等(equality)是以<code>operator==</code>为基础，如果<code>x==y</code>为真，则判定x和y相等。</li><li>等价(equivalence)是以<code>operator&lt;</code>为基础，如果<code>!(x &lt; y) &amp;&amp; !(y &lt; x)</code>为真，则判定x和y等价。</li></ul><p>通常，关联容器采用“等价”，而顺序容器采用“相等”。</p><h2 id="vector-和-list-的区别" tabindex="-1">vector 和 list 的区别 <a class="header-anchor" href="#vector-和-list-的区别" aria-label="Permalink to &quot;vector 和 list 的区别&quot;">​</a></h2><p>vector 和 list 都是常用的数据结构，它们都可以用来存储一组数据。不同之处在于，vector 是一种更高效的数据结构，它的内存分配是连续的，而 list 的内存分配是离散的。这意味着，当需要在 vector 中存储或访问大量数据时，它会比 list 更快。另一方面，list 比 vector 更灵活，因为它允许在任意位置插入或删除元素。总之，两者都有各自的优势，应根据具体情况选择合适的数据结构使用。</p><h2 id="vector-的扩容原理" tabindex="-1">vector 的扩容原理 <a class="header-anchor" href="#vector-的扩容原理" aria-label="Permalink to &quot;vector 的扩容原理&quot;">​</a></h2><p>vector 是一种动态数组，它的内存空间是可以自动扩容的。当在 vector 中添加新元素时，如果 vector 内部的存储空间不够用，那么 vector 会自动分配更多的空间来存储新的元素。</p><p>具体来说，当 vector 的存储空间不够用时，它会把当前的存储空间扩大一倍，然后把原来的数据复制到新的存储空间中。这样就能保证 vector 在扩容时的时间复杂度为 O(1)，即使在 vector 中添加了大量数据，它的性能也不会下降。</p><p>不过，有时候这种自动扩容的方式可能会造成内存的浪费，因为 vector 扩容时会分配更多的空间，但并不一定全部都会被使用。因此，在使用 vector 时，应该根据具体情况来选择合适的扩容策略，以提高 vector 的内存利用率。</p><h2 id="简述-stl-中的-map-的实现原理" tabindex="-1">简述 STL 中的 map 的实现原理 <a class="header-anchor" href="#简述-stl-中的-map-的实现原理" aria-label="Permalink to &quot;简述 STL 中的 map 的实现原理&quot;">​</a></h2><p>STL 中的 map 是一种关联式容器，它可以将键值对存储在一起，每个键都与一个值相关联。map 可以快速查找、插入和删除元素，因此在许多应用场景中都非常有用。</p><p>map 的底层实现通常是基于红黑树这种数据结构，红黑树是一种平衡二叉树，它能够保证查找、插入和删除的时间复杂度都为 O(log n)。在红黑树中，每个节点都有一个颜色（红色或黑色），通过控制节点的颜色和插入、删除的方式，能够保证红黑树的深度接近于log n，从而保证了红黑树的高性能。</p><p>红黑树中的每个节点都存储着一个键值对，并且键是有序的，因此 map 中的元素也是有序的。当插入、查找或删除元素时，map 都会在红黑树中执行相应的操作，从而保证了 map 的高性能。总之，map 是一种非常实用的数据结构，能够满足许多应用场景的需求。</p><h2 id="map-和-unordered-map-的区别" tabindex="-1">map 和 unordered_map 的区别 <a class="header-anchor" href="#map-和-unordered-map-的区别" aria-label="Permalink to &quot;map 和 unordered_map 的区别&quot;">​</a></h2><p>map 和 unordered_map 都是 STL 中的容器，它们都可以用来存储键值对。不同之处在于，map 是一种有序容器，它会根据键的大小自动排序，而 unordered_map 是一种无序容器，它不会对键进行排序。</p><p>另一方面，map 的底层实现是基于红黑树这种数据结构，它的查找、插入和删除操作的时间复杂度都是 O(log n)，而 unordered_map 的底层实现是基于哈希表，它的查找、插入和删除操作的时间复杂度都是 O(1)。</p><p>因此，如果你需要保证键值对的顺序，那么可以使用 map，否则可以使用 unordered_map。另外，如果你需要高性能，那么可以使用 unordered_map，因为它的时间复杂度更低。总之，两者都有各自的优势，应根据具体情况选择合适的容器使用。</p><h2 id="stl-sort-函数的实现" tabindex="-1">stl sort 函数的实现 <a class="header-anchor" href="#stl-sort-函数的实现" aria-label="Permalink to &quot;stl sort 函数的实现&quot;">​</a></h2><p>STL 中的 sort 函数是一种高效的排序算法，它可以对一个数组或容器中的元素进行排序。sort 函数的实现通常是基于快速排序这种排序算法，快速排序的时间复杂度为 O(n log n)，它能够在大多数情况下保证排序的高性能。</p><p>在快速排序中，首先会选择一个基准元素，然后把数组分成两部分，一部分的元素都小于基准元素，另一部分的元素都大于基准元素。接下来，分别对这两部分的元素再次进行快速排序，直到所有的元素都排好序为止。</p><p>STL 中的 sort 函数也是采用类似的方式来实现的。首先，它会选择一个基准元素，然后把容器中的元素分成两部分，一部分的元素都小于基准元素，另一部分的元素都大于基准元素。接着，分别对这两部分的元素再次进行快速排序，直到所有的元素都排好序为止。总之，sort 函数是一种非常实用的排序工具，能够满足许多应用场景的需求。</p><h2 id="stl容器里哪个是线程安全的" tabindex="-1">stl容器里哪个是线程安全的 <a class="header-anchor" href="#stl容器里哪个是线程安全的" aria-label="Permalink to &quot;stl容器里哪个是线程安全的&quot;">​</a></h2><p>STL容器指的是C++标准模板库中的容器。需要明确的是，没有任何STL容器是线程安全的。这就意味着，如果你在多线程环境下使用STL容器（比如vector，list，map，set等等）而没有提供额外的同步操作，你的代码是可能出现并发问题的。</p><p>然而，可以通过使用互斥锁等机制，使得访问和修改STL容器的操作变得原子性，从而实现线程安全。</p><p>唯一提供某种程度线程安全的是C++11标准提供的一些线程安全容器（在<code>&lt;atomic&gt;</code>和<code>&lt;thread&gt;</code>库中），如atomic类型等。但这并不意味着它们可以在任何情况下都安全使用。这些都需要开发者有合理的并发控制策略和足够的编程技巧。</p><p>总结一下，<strong>STL中的所有容器都不是线程安全的，需要程序员自己保证线程安全性。</strong></p><p>STL 容器提供了许多常用的数据结构，如 vector、list、set 等。但是，由于它们不是线程安全的，所以在多线程环境下使用时需要注意。</p><p>在多线程环境下，同一个 STL 容器的不同线程可能同时对其进行写操作，如果不加锁的话，可能会导致数据冲突和数据不一致的问题。例如，下面的代码使用了 STL 中的 vector 模板类来实现一个线程不安全的示例：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">#include</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&lt;vector&gt;</span></span>
<span class="line"><span style="color:#F97583;">#include</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&lt;thread&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::vector</span><span style="color:#F97583;">&lt;int&gt;</span><span style="color:#E1E4E8;"> v;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">add_value</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">value</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#E1E4E8;">    v.</span><span style="color:#B392F0;">push_back</span><span style="color:#E1E4E8;">(value);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::thread </span><span style="color:#B392F0;">t1</span><span style="color:#E1E4E8;">(add_value, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::thread </span><span style="color:#B392F0;">t2</span><span style="color:#E1E4E8;">(add_value, </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::thread </span><span style="color:#B392F0;">t3</span><span style="color:#E1E4E8;">(add_value, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::thread </span><span style="color:#B392F0;">t4</span><span style="color:#E1E4E8;">(add_value, </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    t1.</span><span style="color:#B392F0;">join</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    t2.</span><span style="color:#B392F0;">join</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    t3.</span><span style="color:#B392F0;">join</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    t4.</span><span style="color:#B392F0;">join</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">#include</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&lt;vector&gt;</span></span>
<span class="line"><span style="color:#D73A49;">#include</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&lt;thread&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::vector</span><span style="color:#D73A49;">&lt;int&gt;</span><span style="color:#24292E;"> v;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">add_value</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">value</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">    v.</span><span style="color:#6F42C1;">push_back</span><span style="color:#24292E;">(value);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::thread </span><span style="color:#6F42C1;">t1</span><span style="color:#24292E;">(add_value, </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::thread </span><span style="color:#6F42C1;">t2</span><span style="color:#24292E;">(add_value, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::thread </span><span style="color:#6F42C1;">t3</span><span style="color:#24292E;">(add_value, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::thread </span><span style="color:#6F42C1;">t4</span><span style="color:#24292E;">(add_value, </span><span style="color:#005CC5;">4</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    t1.</span><span style="color:#6F42C1;">join</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    t2.</span><span style="color:#6F42C1;">join</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    t3.</span><span style="color:#6F42C1;">join</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    t4.</span><span style="color:#6F42C1;">join</span><span style="color:#24292E;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在上面的代码中，v 是一个全局变量，它是 vector 类型的。程序启动了四个线程，每个线程都调用了 add_value 函数，并向 v 中添加了一个值。但是，由于 v 是线程不安全的，所以如果不加锁的话，它可能会导致数据冲突和数据不一致的问题。</p><p>为了解决线程不安全的问题，可以在使用 STL 容器时使用同步机制，如互斥锁或信号量。例如，下面的代码使用了互斥锁来保证 vector 是线程安全的：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">#include</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&lt;vector&gt;</span></span>
<span class="line"><span style="color:#F97583;">#include</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&lt;thread&gt;</span></span>
<span class="line"><span style="color:#F97583;">#include</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&lt;mutex&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::vector</span><span style="color:#F97583;">&lt;int&gt;</span><span style="color:#E1E4E8;"> v;</span></span>
<span class="line"><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::mutex m;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">add_value</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">value</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::lock_guard</span><span style="color:#F97583;">&lt;</span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::mutex</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">(m);</span></span>
<span class="line"><span style="color:#E1E4E8;">    v.</span><span style="color:#B392F0;">push_back</span><span style="color:#E1E4E8;">(value);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::thread </span><span style="color:#B392F0;">t1</span><span style="color:#E1E4E8;">(add_value, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::thread </span><span style="color:#B392F0;">t2</span><span style="color:#E1E4E8;">(add_value, </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::thread </span><span style="color:#B392F0;">t3</span><span style="color:#E1E4E8;">(add_value, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">std</span><span style="color:#E1E4E8;">::thread </span><span style="color:#B392F0;">t4</span><span style="color:#E1E4E8;">(add_value, </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    t1.</span><span style="color:#B392F0;">join</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    t2.</span><span style="color:#B392F0;">join</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    t3.</span><span style="color:#B392F0;">join</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    t4.</span><span style="color:#B392F0;">join</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">#include</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&lt;vector&gt;</span></span>
<span class="line"><span style="color:#D73A49;">#include</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&lt;thread&gt;</span></span>
<span class="line"><span style="color:#D73A49;">#include</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&lt;mutex&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::vector</span><span style="color:#D73A49;">&lt;int&gt;</span><span style="color:#24292E;"> v;</span></span>
<span class="line"><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::mutex m;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">add_value</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">value</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::lock_guard</span><span style="color:#D73A49;">&lt;</span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::mutex</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">(m);</span></span>
<span class="line"><span style="color:#24292E;">    v.</span><span style="color:#6F42C1;">push_back</span><span style="color:#24292E;">(value);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::thread </span><span style="color:#6F42C1;">t1</span><span style="color:#24292E;">(add_value, </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::thread </span><span style="color:#6F42C1;">t2</span><span style="color:#24292E;">(add_value, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::thread </span><span style="color:#6F42C1;">t3</span><span style="color:#24292E;">(add_value, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">std</span><span style="color:#24292E;">::thread </span><span style="color:#6F42C1;">t4</span><span style="color:#24292E;">(add_value, </span><span style="color:#005CC5;">4</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    t1.</span><span style="color:#6F42C1;">join</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    t2.</span><span style="color:#6F42C1;">join</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    t3.</span><span style="color:#6F42C1;">join</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    t4.</span><span style="color:#6F42C1;">join</span><span style="color:#24292E;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在上面的代码中，vector 模板类用于实现一个动态数组。为了保证 vector 是线程安全的，程序使用了互斥锁来同步多个线程的访问。在调用 add_value 函数时，会先加锁，然后再调用 vector 的 push_back 方法，并在函数结束时自动解锁。这样就能保证 vector 是线程安全的了。</p>`,77),o=[t];function e(c,r,y,E,i,d){return n(),a("div",null,o)}const g=s(p,[["render",e]]);export{v as __pageData,g as default};
